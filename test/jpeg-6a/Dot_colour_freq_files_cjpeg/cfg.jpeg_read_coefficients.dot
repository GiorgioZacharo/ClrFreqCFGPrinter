digraph "CFG for 'jpeg_read_coefficients' function" {
	label="CFG for 'jpeg_read_coefficients' function";

	Node0x6a1e4c0 [shape=record,label="{entry:\l  %global_state = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 4\l  %0 = load i32, i32* %global_state, align 4, !tbaa !2\l  switch i32 %0, label %if.then4 [\l    i32 202, label %if.then\l    i32 209, label %entry.for.cond.preheader_crit_edge\l  ]\l|{<s0>def|<s1>202|<s2>209}}"];
	Node0x6a1e4c0:s0 -> Node0x6a1fde0;
	Node0x6a1e4c0:s1 -> Node0x6a1ff00;
	Node0x6a1e4c0:s2 -> Node0x6a20040;
	Node0x6a20040 [shape=record,label="{entry.for.cond.preheader_crit_edge:               \l  %.pre59 = bitcast %struct.jpeg_decompress_struct* %cinfo to\l... %struct.jpeg_common_struct*\l  br label %for.cond.preheader\l}"];
	Node0x6a20040 -> Node0x6a20280;
	Node0x6a1ff00 [shape=record,label="{if.then:                                          \l  %arith_code.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 45\l  %1 = load i32, i32* %arith_code.i, align 4, !tbaa !10\l  %tobool.i = icmp eq i32 %1, 0\l  br i1 %tobool.i, label %if.else.i, label %if.then.i\l|{<s0>T|<s1>F}}"];
	Node0x6a1ff00:s0 -> Node0x6a206d0;
	Node0x6a1ff00:s1 -> Node0x6a207b0;
	Node0x6a207b0 [shape=record,label="{if.then.i:                                        \l  %err.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0\l  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8,\l... !tbaa !11\l  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr,\l... %struct.jpeg_error_mgr* %2, i64 0, i32 5\l  store i32 1, i32* %msg_code.i, align 8, !tbaa !12\l  %error_exit.i = getelementptr inbounds %struct.jpeg_error_mgr,\l... %struct.jpeg_error_mgr* %2, i64 0, i32 0\l  %3 = load void (%struct.jpeg_common_struct*)*, void\l... (%struct.jpeg_common_struct*)** %error_exit.i, align 8, !tbaa !15\l  %4 = bitcast %struct.jpeg_decompress_struct* %cinfo to\l... %struct.jpeg_common_struct*\l  tail call void %3(%struct.jpeg_common_struct* %4) #2\l  br label %if.end5.i\l}"];
	Node0x6a207b0 -> Node0x6a21300;
	Node0x6a206d0 [shape=record,label="{if.else.i:                                        \l  %progressive_mode.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 44\l  %5 = load i32, i32* %progressive_mode.i, align 8, !tbaa !16\l  %tobool2.i = icmp eq i32 %5, 0\l  br i1 %tobool2.i, label %if.else4.i, label %if.then3.i\l|{<s0>T|<s1>F}}"];
	Node0x6a206d0:s0 -> Node0x6a21700;
	Node0x6a206d0:s1 -> Node0x6a217e0;
	Node0x6a217e0 [shape=record,label="{if.then3.i:                                       \l  tail call void @jinit_phuff_decoder(%struct.jpeg_decompress_struct* nonnull\l... %cinfo) #2\l  br label %if.end5.i\l}"];
	Node0x6a217e0 -> Node0x6a21300;
	Node0x6a21700 [shape=record,label="{if.else4.i:                                       \l  tail call void @jinit_huff_decoder(%struct.jpeg_decompress_struct* nonnull\l... %cinfo) #2\l  br label %if.end5.i\l}"];
	Node0x6a21700 -> Node0x6a21300;
	Node0x6a21300 [shape=record,label="{if.end5.i:                                        \l  tail call void @jinit_d_coef_controller(%struct.jpeg_decompress_struct*\l... nonnull %cinfo, i32 1) #2\l  %mem.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 1\l  %6 = load %struct.jpeg_memory_mgr*, %struct.jpeg_memory_mgr** %mem.i, align\l... 8, !tbaa !17\l  %realize_virt_arrays.i = getelementptr inbounds %struct.jpeg_memory_mgr,\l... %struct.jpeg_memory_mgr* %6, i64 0, i32 6\l  %realize_virt_arrays6.i = bitcast \{\}** %realize_virt_arrays.i to void\l... (%struct.jpeg_common_struct*)**\l  %7 = load void (%struct.jpeg_common_struct*)*, void\l... (%struct.jpeg_common_struct*)** %realize_virt_arrays6.i, align 8, !tbaa !18\l  %8 = bitcast %struct.jpeg_decompress_struct* %cinfo to\l... %struct.jpeg_common_struct*\l  tail call void %7(%struct.jpeg_common_struct* %8) #2\l  %inputctl.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 77\l  %9 = load %struct.jpeg_input_controller*, %struct.jpeg_input_controller**\l... %inputctl.i, align 8, !tbaa !20\l  %start_input_pass.i = getelementptr inbounds %struct.jpeg_input_controller,\l... %struct.jpeg_input_controller* %9, i64 0, i32 2\l  %10 = load void (%struct.jpeg_decompress_struct*)*, void\l... (%struct.jpeg_decompress_struct*)** %start_input_pass.i, align 8, !tbaa !21\l  tail call void %10(%struct.jpeg_decompress_struct* nonnull %cinfo) #2\l  %progress.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 2\l  %11 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr**\l... %progress.i, align 8, !tbaa !23\l  %cmp.i = icmp eq %struct.jpeg_progress_mgr* %11, null\l  br i1 %cmp.i, label %transdecode_master_selection.exit, label %if.then7.i\l|{<s0>T|<s1>F}}"];
	Node0x6a21300:s0 -> Node0x6a237a0;
	Node0x6a21300:s1 -> Node0x6a238c0;
	Node0x6a238c0 [shape=record,label="{if.then7.i:                                       \l  %progressive_mode8.i = getelementptr inbounds\l... %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64\l... 0, i32 44\l  %12 = load i32, i32* %progressive_mode8.i, align 8, !tbaa !16\l  %tobool9.i = icmp eq i32 %12, 0\l  br i1 %tobool9.i, label %if.else11.i, label %if.then10.i\l|{<s0>T|<s1>F}}"];
	Node0x6a238c0:s0 -> Node0x6a24190;
	Node0x6a238c0:s1 -> Node0x6a24270;
	Node0x6a24270 [shape=record,label="{if.then10.i:                                      \l  %num_components.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 8\l  %13 = load i32, i32* %num_components.i, align 8, !tbaa !24\l  %mul.i = mul nsw i32 %13, 3\l  %add.i = add nsw i32 %mul.i, 2\l  br label %if.end18.i\l}"];
	Node0x6a24270 -> Node0x6a247d0;
	Node0x6a24190 [shape=record,label="{if.else11.i:                                      \l  %14 = load %struct.jpeg_input_controller*, %struct.jpeg_input_controller**\l... %inputctl.i, align 8, !tbaa !20\l  %has_multiple_scans.i = getelementptr inbounds\l... %struct.jpeg_input_controller, %struct.jpeg_input_controller* %14, i64 0, i32\l... 4\l  %15 = load i32, i32* %has_multiple_scans.i, align 8, !tbaa !25\l  %tobool13.i = icmp eq i32 %15, 0\l  br i1 %tobool13.i, label %if.end18.i, label %if.then14.i\l|{<s0>T|<s1>F}}"];
	Node0x6a24190:s0 -> Node0x6a247d0;
	Node0x6a24190:s1 -> Node0x6a25200;
	Node0x6a25200 [shape=record,label="{if.then14.i:                                      \l  %num_components15.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 8\l  %16 = load i32, i32* %num_components15.i, align 8, !tbaa !24\l  br label %if.end18.i\l}"];
	Node0x6a25200 -> Node0x6a247d0;
	Node0x6a247d0 [shape=record,label="{if.end18.i:                                       \l  %nscans.0.i = phi i32 [ %add.i, %if.then10.i ], [ %16, %if.then14.i ], [ 1,\l... %if.else11.i ]\l  %pass_counter.i = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %11, i64 0, i32 1\l  store i64 0, i64* %pass_counter.i, align 8, !tbaa !26\l  %total_iMCU_rows.i = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 60\l  %17 = load i32, i32* %total_iMCU_rows.i, align 8, !tbaa !28\l  %conv.i = zext i32 %17 to i64\l  %conv20.i = sext i32 %nscans.0.i to i64\l  %mul21.i = mul nsw i64 %conv.i, %conv20.i\l  %pass_limit.i = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %11, i64 0, i32 2\l  store i64 %mul21.i, i64* %pass_limit.i, align 8, !tbaa !29\l  %completed_passes.i = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %11, i64 0, i32 3\l  store i32 0, i32* %completed_passes.i, align 8, !tbaa !30\l  %total_passes.i = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %11, i64 0, i32 4\l  store i32 1, i32* %total_passes.i, align 4, !tbaa !31\l  br label %transdecode_master_selection.exit\l}"];
	Node0x6a247d0 -> Node0x6a237a0;
	Node0x6a237a0 [shape=record,label="{transdecode_master_selection.exit:                \l  store i32 209, i32* %global_state, align 4, !tbaa !2\l  br label %for.cond.preheader\l}"];
	Node0x6a237a0 -> Node0x6a20280;
	Node0x6a1fde0 [shape=record,label="{if.then4:                                         \l  %err = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0\l  %18 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8,\l... !tbaa !11\l  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr,\l... %struct.jpeg_error_mgr* %18, i64 0, i32 5\l  store i32 18, i32* %msg_code, align 8, !tbaa !12\l  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr,\l... %struct.jpeg_error_mgr* %18, i64 0, i32 6, i32 0, i64 0\l  store i32 %0, i32* %arrayidx, align 4, !tbaa !32\l  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr,\l... %struct.jpeg_error_mgr* %18, i64 0, i32 0\l  %19 = load void (%struct.jpeg_common_struct*)*, void\l... (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !15\l  %20 = bitcast %struct.jpeg_decompress_struct* %cinfo to\l... %struct.jpeg_common_struct*\l  tail call void %19(%struct.jpeg_common_struct* %20) #2\l  br label %for.cond.preheader\l}"];
	Node0x6a1fde0 -> Node0x6a20280;
	Node0x6a20280 [shape=record,label="{for.cond.preheader:                               \l  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre59,\l... %entry.for.cond.preheader_crit_edge ], [ %20, %if.then4 ], [ %8,\l... %transdecode_master_selection.exit ]\l  %progress = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 2\l  %inputctl = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 77\l  %total_iMCU_rows = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 60\l  %.pre = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr**\l... %progress, align 8, !tbaa !23\l  br label %for.cond\l}"];
	Node0x6a20280 -> Node0x6a29bb0;
	Node0x6a29bb0 [shape=record,label="{for.cond:                                         \l  %21 = phi %struct.jpeg_progress_mgr* [ %.pre, %for.cond.preheader ], [ %25,\l... %for.cond.backedge ]\l  %cmp9 = icmp eq %struct.jpeg_progress_mgr* %21, null\l  br i1 %cmp9, label %if.end13, label %if.then10\l|{<s0>T|<s1>F}}"];
	Node0x6a29bb0:s0 -> Node0x6a29f40;
	Node0x6a29bb0:s1 -> Node0x6a29ff0;
	Node0x6a29ff0 [shape=record,label="{if.then10:                                        \l  %progress_monitor12 = bitcast %struct.jpeg_progress_mgr* %21 to void\l... (%struct.jpeg_common_struct*)**\l  %22 = load void (%struct.jpeg_common_struct*)*, void\l... (%struct.jpeg_common_struct*)** %progress_monitor12, align 8, !tbaa !33\l  tail call void %22(%struct.jpeg_common_struct* %.pre-phi) #2\l  br label %if.end13\l}"];
	Node0x6a29ff0 -> Node0x6a29f40;
	Node0x6a29f40 [shape=record,label="{if.end13:                                         \l  %23 = load %struct.jpeg_input_controller*, %struct.jpeg_input_controller**\l... %inputctl, align 8, !tbaa !20\l  %consume_input = getelementptr inbounds %struct.jpeg_input_controller,\l... %struct.jpeg_input_controller* %23, i64 0, i32 0\l  %24 = load i32 (%struct.jpeg_decompress_struct*)*, i32\l... (%struct.jpeg_decompress_struct*)** %consume_input, align 8, !tbaa !34\l  %call = tail call i32 %24(%struct.jpeg_decompress_struct* nonnull %cinfo) #2\l  switch i32 %call, label %if.end19 [\l    i32 0, label %return.loopexit\l    i32 2, label %for.end\l  ]\l|{<s0>def|<s1>0|<s2>2}}"];
	Node0x6a29f40:s0 -> Node0x6a2a830;
	Node0x6a29f40:s1 -> Node0x6a2a8e0;
	Node0x6a29f40:s2 -> Node0x6a2a9c0;
	Node0x6a2a830 [shape=record,label="{if.end19:                                         \l  %25 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr**\l... %progress, align 8, !tbaa !23\l  %cmp21 = icmp ne %struct.jpeg_progress_mgr* %25, null\l  %26 = or i32 %call, 2\l  %27 = icmp eq i32 %26, 3\l  %or.cond = and i1 %27, %cmp21\l  br i1 %or.cond, label %if.then24, label %for.cond.backedge\l|{<s0>T|<s1>F}}"];
	Node0x6a2a830:s0 -> Node0x6a2add0;
	Node0x6a2a830:s1 -> Node0x6a29d70;
	Node0x6a29d70 [shape=record,label="{for.cond.backedge:                                \l  br label %for.cond\l}"];
	Node0x6a29d70 -> Node0x6a29bb0;
	Node0x6a2add0 [shape=record,label="{if.then24:                                        \l  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %25, i64 0, i32 1\l  %28 = load i64, i64* %pass_counter, align 8, !tbaa !26\l  %inc = add nsw i64 %28, 1\l  store i64 %inc, i64* %pass_counter, align 8, !tbaa !26\l  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr,\l... %struct.jpeg_progress_mgr* %25, i64 0, i32 2\l  %29 = load i64, i64* %pass_limit, align 8, !tbaa !29\l  %cmp27 = icmp slt i64 %inc, %29\l  br i1 %cmp27, label %for.cond.backedge, label %if.then28\l|{<s0>T|<s1>F}}"];
	Node0x6a2add0:s0 -> Node0x6a29d70;
	Node0x6a2add0:s1 -> Node0x6a2bf00;
	Node0x6a2bf00 [shape=record,label="{if.then28:                                        \l  %30 = load i32, i32* %total_iMCU_rows, align 8, !tbaa !28\l  %conv = zext i32 %30 to i64\l  %add = add nsw i64 %conv, %29\l  store i64 %add, i64* %pass_limit, align 8, !tbaa !29\l  br label %for.cond.backedge\l}"];
	Node0x6a2bf00 -> Node0x6a29d70;
	Node0x6a2a9c0 [shape=record,label="{for.end:                                          \l  store i32 210, i32* %global_state, align 4, !tbaa !2\l  %coef = getelementptr inbounds %struct.jpeg_decompress_struct,\l... %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 75\l  %31 = load %struct.jpeg_d_coef_controller*, %struct.jpeg_d_coef_controller**\l... %coef, align 8, !tbaa !35\l  %coef_arrays = getelementptr inbounds %struct.jpeg_d_coef_controller,\l... %struct.jpeg_d_coef_controller* %31, i64 0, i32 4\l  %32 = load %struct.jvirt_barray_control**, %struct.jvirt_barray_control***\l... %coef_arrays, align 8, !tbaa !36\l  br label %return\l}"];
	Node0x6a2a9c0 -> Node0x6a25a50;
	Node0x6a2a8e0 [shape=record,label="{return.loopexit:                                  \l  br label %return\l}"];
	Node0x6a2a8e0 -> Node0x6a25a50;
	Node0x6a25a50 [shape=record,label="{return:                                           \l  %retval.2 = phi %struct.jvirt_barray_control** [ %32, %for.end ], [ null,\l... %return.loopexit ]\l  ret %struct.jvirt_barray_control** %retval.2\l}"];
}

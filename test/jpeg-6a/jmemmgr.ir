; ModuleID = 'jmemmgr.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.jpeg_common_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32 }
%struct.jpeg_error_mgr = type { {}*, void (%struct.jpeg_common_struct*, i32)*, {}*, void (%struct.jpeg_common_struct*, i8*)*, {}*, i32, %union.anon, i32, i64, i8**, i32, i8**, i32, i32 }
%union.anon = type { [8 x i32], [48 x i8] }
%struct.jpeg_memory_mgr = type { i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)*, i8** (%struct.jpeg_common_struct*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)*, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, {}*, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)*, void (%struct.jpeg_common_struct*, i32)*, {}*, i64 }
%struct.jvirt_sarray_control = type { i8**, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.jvirt_sarray_control*, %struct.backing_store_struct }
%struct.backing_store_struct = type { void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*)*, %struct._IO_FILE*, [64 x i8] }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.jvirt_barray_control = type { [64 x i16]**, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.jvirt_barray_control*, %struct.backing_store_struct }
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
%union.small_pool_struct = type { %struct.anon }
%struct.anon = type { %union.small_pool_struct*, i64, i64 }
%union.large_pool_struct = type { %struct.anon.0 }
%struct.anon.0 = type { %union.large_pool_struct*, i64, i64 }
%struct.my_memory_mgr = type { %struct.jpeg_memory_mgr, [2 x %union.small_pool_struct*], [2 x %union.large_pool_struct*], %struct.jvirt_sarray_control*, %struct.jvirt_barray_control*, i64, i32 }

@.str = private unnamed_addr constant [8 x i8] c"JPEGMEM\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"%ld%c\00", align 1
@first_pool_slop = internal unnamed_addr constant [2 x i64] [i64 1600, i64 16000], align 16
@extra_pool_slop = internal unnamed_addr constant [2 x i64] [i64 0, i64 5000], align 16

; Function Attrs: nounwind uwtable
define void @jinit_memory_mgr(%struct.jpeg_common_struct* %cinfo) #0 !prof !2 {
entry:
  %max_to_use = alloca i64, align 8
  %ch = alloca i8, align 1
  %0 = bitcast i64* %max_to_use to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #5
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  store %struct.jpeg_memory_mgr* null, %struct.jpeg_memory_mgr** %mem1, align 8, !tbaa !3
  %call = tail call i64 @jpeg_mem_init(%struct.jpeg_common_struct* %cinfo) #5
  store i64 %call, i64* %max_to_use, align 8, !tbaa !9
  %call4 = tail call i8* @jpeg_get_small(%struct.jpeg_common_struct* %cinfo, i64 160) #5
  %cmp5 = icmp eq i8* %call4, null
  br i1 %cmp5, label %if.then6, label %if.end13, !prof !11

if.then6:                                         ; preds = %entry
  tail call void @jpeg_mem_term(%struct.jpeg_common_struct* nonnull %cinfo) #5
  %err7 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %1 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err7, align 8, !tbaa !12
  %msg_code8 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  store i32 53, i32* %msg_code8, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
  store i32 0, i32* %arrayidx, align 4, !tbaa !15
  %2 = bitcast %struct.jpeg_error_mgr* %1 to void (%struct.jpeg_common_struct*)**
  %3 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %2, align 8, !tbaa !16
  tail call void %3(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end13

if.end13:                                         ; preds = %if.then6, %entry
  %4 = bitcast i8* %call4 to <2 x i8* (%struct.jpeg_common_struct*, i32, i64)*>*
  store <2 x i8* (%struct.jpeg_common_struct*, i32, i64)*> <i8* (%struct.jpeg_common_struct*, i32, i64)* @alloc_small, i8* (%struct.jpeg_common_struct*, i32, i64)* @alloc_large>, <2 x i8* (%struct.jpeg_common_struct*, i32, i64)*>* %4, align 8, !tbaa !17
  %alloc_sarray = getelementptr inbounds i8, i8* %call4, i64 16
  %5 = bitcast i8* %alloc_sarray to i8** (%struct.jpeg_common_struct*, i32, i32, i32)**
  store i8** (%struct.jpeg_common_struct*, i32, i32, i32)* @alloc_sarray, i8** (%struct.jpeg_common_struct*, i32, i32, i32)** %5, align 8, !tbaa !18
  %alloc_barray = getelementptr inbounds i8, i8* %call4, i64 24
  %6 = bitcast i8* %alloc_barray to [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)**
  store [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)* @alloc_barray, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)** %6, align 8, !tbaa !21
  %request_virt_sarray = getelementptr inbounds i8, i8* %call4, i64 32
  %7 = bitcast i8* %request_virt_sarray to %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)**
  store %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)* @request_virt_sarray, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)** %7, align 8, !tbaa !22
  %request_virt_barray = getelementptr inbounds i8, i8* %call4, i64 40
  %8 = bitcast i8* %request_virt_barray to %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)**
  store %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)* @request_virt_barray, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)** %8, align 8, !tbaa !23
  %realize_virt_arrays = getelementptr inbounds i8, i8* %call4, i64 48
  %realize_virt_arrays20 = bitcast i8* %realize_virt_arrays to void (%struct.jpeg_common_struct*)**
  store void (%struct.jpeg_common_struct*)* @realize_virt_arrays, void (%struct.jpeg_common_struct*)** %realize_virt_arrays20, align 8, !tbaa !24
  %access_virt_sarray = getelementptr inbounds i8, i8* %call4, i64 56
  %9 = bitcast i8* %access_virt_sarray to i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)**
  store i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)* @access_virt_sarray, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)** %9, align 8, !tbaa !25
  %access_virt_barray = getelementptr inbounds i8, i8* %call4, i64 64
  %10 = bitcast i8* %access_virt_barray to [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)**
  store [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)* @access_virt_barray, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)** %10, align 8, !tbaa !26
  %free_pool = getelementptr inbounds i8, i8* %call4, i64 72
  %11 = bitcast i8* %free_pool to void (%struct.jpeg_common_struct*, i32)**
  store void (%struct.jpeg_common_struct*, i32)* @free_pool, void (%struct.jpeg_common_struct*, i32)** %11, align 8, !tbaa !27
  %self_destruct = getelementptr inbounds i8, i8* %call4, i64 80
  %self_destruct25 = bitcast i8* %self_destruct to void (%struct.jpeg_common_struct*)**
  store void (%struct.jpeg_common_struct*)* @self_destruct, void (%struct.jpeg_common_struct*)** %self_destruct25, align 8, !tbaa !28
  %max_memory_to_use = getelementptr inbounds i8, i8* %call4, i64 88
  %12 = bitcast i8* %max_memory_to_use to i64*
  store i64 %call, i64* %12, align 8, !tbaa !29
  %small_list = getelementptr inbounds i8, i8* %call4, i64 96
  %large_list = getelementptr inbounds i8, i8* %call4, i64 112
  %13 = bitcast i8* %small_list to <2 x %union.small_pool_struct*>*
  store <2 x %union.small_pool_struct*> zeroinitializer, <2 x %union.small_pool_struct*>* %13, align 8, !tbaa !17
  %14 = bitcast i8* %large_list to <2 x %union.large_pool_struct*>*
  store <2 x %union.large_pool_struct*> zeroinitializer, <2 x %union.large_pool_struct*>* %14, align 8, !tbaa !17
  %virt_sarray_list = getelementptr inbounds i8, i8* %call4, i64 128
  %total_space_allocated = getelementptr inbounds i8, i8* %call4, i64 144
  %15 = bitcast i8* %total_space_allocated to i64*
  call void @llvm.memset.p0i8.i64(i8* %virt_sarray_list, i8 0, i64 16, i32 8, i1 false)
  store i64 160, i64* %15, align 8, !tbaa !30
  %16 = bitcast %struct.jpeg_memory_mgr** %mem1 to i8**
  store i8* %call4, i8** %16, align 8, !tbaa !3
  %call33 = tail call i8* @getenv(i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i64 0, i64 0)) #5
  %cmp34 = icmp eq i8* %call33, null
  br i1 %cmp34, label %if.end50, label %if.then35, !prof !31

if.then35:                                        ; preds = %if.end13
  call void @llvm.lifetime.start(i64 1, i8* nonnull %ch) #5
  store i8 120, i8* %ch, align 1, !tbaa !32
  %call36 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* nonnull %call33, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.1, i64 0, i64 0), i64* nonnull %max_to_use, i8* nonnull %ch) #5
  %cmp37 = icmp sgt i32 %call36, 0
  br i1 %cmp37, label %if.then38, label %if.end49

if.then38:                                        ; preds = %if.then35
  %17 = load i8, i8* %ch, align 1, !tbaa !32
  switch i8 %17, label %if.then38.if.end45_crit_edge [
    i8 109, label %if.then44
    i8 77, label %if.then44
  ]

if.then38.if.end45_crit_edge:                     ; preds = %if.then38
  %.pre = load i64, i64* %max_to_use, align 8, !tbaa !9
  br label %if.end45

if.then44:                                        ; preds = %if.then38, %if.then38
  %18 = load i64, i64* %max_to_use, align 8, !tbaa !9
  %mul = mul nsw i64 %18, 1000
  store i64 %mul, i64* %max_to_use, align 8, !tbaa !9
  br label %if.end45

if.end45:                                         ; preds = %if.then38.if.end45_crit_edge, %if.then44
  %19 = phi i64 [ %.pre, %if.then38.if.end45_crit_edge ], [ %mul, %if.then44 ]
  %mul46 = mul nsw i64 %19, 1000
  store i64 %mul46, i64* %12, align 8, !tbaa !29
  br label %if.end49

if.end49:                                         ; preds = %if.end45, %if.then35
  call void @llvm.lifetime.end(i64 1, i8* nonnull %ch) #5
  br label %if.end50

if.end50:                                         ; preds = %if.end13, %if.end49
  call void @llvm.lifetime.end(i64 8, i8* %0) #5
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

declare i64 @jpeg_mem_init(%struct.jpeg_common_struct*) #2

declare i8* @jpeg_get_small(%struct.jpeg_common_struct*, i64) #2

declare void @jpeg_mem_term(%struct.jpeg_common_struct*) #2

; Function Attrs: nounwind uwtable
define internal i8* @alloc_small(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i64 %sizeofobject) #0 !prof !33 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp = icmp ugt i64 %sizeofobject, 999999976
  br i1 %cmp, label %if.then, label %if.end, !prof !34

if.then:                                          ; preds = %entry
  %err.i = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !12
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 53, i32* %msg_code.i, align 8, !tbaa !13
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
  store i32 1, i32* %arrayidx.i, align 4, !tbaa !15
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rem = and i64 %sizeofobject, 7
  %cmp2 = icmp eq i64 %rem, 0
  %sub = sub nsw i64 8, %rem
  %add = select i1 %cmp2, i64 0, i64 %sub
  %sizeofobject.addr.0 = add i64 %add, %sizeofobject
  %5 = icmp ugt i32 %pool_id, 1
  br i1 %5, label %if.then7, label %if.end11, !prof !35

if.then7:                                         ; preds = %if.end
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %6 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  store i32 12, i32* %msg_code, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
  store i32 %pool_id, i32* %arrayidx, align 4, !tbaa !15
  %7 = bitcast %struct.jpeg_error_mgr* %6 to void (%struct.jpeg_common_struct*)**
  %8 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %7, align 8, !tbaa !16
  tail call void %8(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then7
  %idxprom = sext i32 %pool_id to i64
  %arrayidx12 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 1, i64 %idxprom
  %hdr_ptr.0132 = load %union.small_pool_struct*, %union.small_pool_struct** %arrayidx12, align 8, !tbaa !17
  %cond133 = icmp eq %union.small_pool_struct* %hdr_ptr.0132, null
  br i1 %cond133, label %if.then19, label %while.body.preheader, !prof !36

while.body.preheader:                             ; preds = %if.end11
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %if.end16
  %hdr_ptr.0134 = phi %union.small_pool_struct* [ %hdr_ptr.0, %if.end16 ], [ %hdr_ptr.0132, %while.body.preheader ]
  %bytes_left = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %hdr_ptr.0134, i64 0, i32 0, i32 2
  %9 = load i64, i64* %bytes_left, align 8, !tbaa !37
  %cmp14 = icmp ult i64 %9, %sizeofobject.addr.0
  br i1 %cmp14, label %if.end16, label %if.end57.loopexit, !prof !39

if.end16:                                         ; preds = %while.body
  %next = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %hdr_ptr.0134, i64 0, i32 0, i32 0
  %hdr_ptr.0 = load %union.small_pool_struct*, %union.small_pool_struct** %next, align 8, !tbaa !17
  %cond = icmp eq %union.small_pool_struct* %hdr_ptr.0, null
  br i1 %cond, label %if.then19.loopexit, label %while.body, !prof !36

if.then19.loopexit:                               ; preds = %if.end16
  %hdr_ptr.0134.lcssa148 = phi %union.small_pool_struct* [ %hdr_ptr.0134, %if.end16 ]
  br label %if.then19

if.then19:                                        ; preds = %if.then19.loopexit, %if.end11
  %prev_hdr_ptr.0.lcssa = phi %union.small_pool_struct* [ null, %if.end11 ], [ %hdr_ptr.0134.lcssa148, %if.then19.loopexit ]
  %add20 = add i64 %sizeofobject.addr.0, 24
  %cmp21 = icmp eq %union.small_pool_struct* %prev_hdr_ptr.0.lcssa, null
  %first_pool_slop.extra_pool_slop = select i1 %cmp21, [2 x i64]* @first_pool_slop, [2 x i64]* @extra_pool_slop
  %slop.0.in = getelementptr inbounds [2 x i64], [2 x i64]* %first_pool_slop.extra_pool_slop, i64 0, i64 %idxprom
  %slop.0 = load i64, i64* %slop.0.in, align 8, !tbaa !9
  %sub28 = sub i64 999999976, %sizeofobject.addr.0
  %cmp29 = icmp ugt i64 %slop.0, %sub28
  %sub28.slop.0 = select i1 %cmp29, i64 %sub28, i64 %slop.0
  %add33125 = add i64 %add20, %sub28.slop.0
  %call126 = tail call i8* @jpeg_get_small(%struct.jpeg_common_struct* %cinfo, i64 %add33125) #5
  %cmp34127 = icmp eq i8* %call126, null
  br i1 %cmp34127, label %if.end36.lr.ph, label %for.end, !prof !40

if.end36.lr.ph:                                   ; preds = %if.then19
  %err.i120 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  br label %if.end36

if.end36:                                         ; preds = %if.end36.lr.ph, %for.cond.backedge
  %slop.1128 = phi i64 [ %sub28.slop.0, %if.end36.lr.ph ], [ %div, %for.cond.backedge ]
  %div = lshr i64 %slop.1128, 1
  %cmp37 = icmp ult i64 %slop.1128, 100
  br i1 %cmp37, label %if.then38, label %for.cond.backedge

if.then38:                                        ; preds = %if.end36
  %10 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i120, align 8, !tbaa !12
  %msg_code.i121 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  store i32 53, i32* %msg_code.i121, align 8, !tbaa !13
  %arrayidx.i122 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
  store i32 2, i32* %arrayidx.i122, align 4, !tbaa !15
  %11 = bitcast %struct.jpeg_error_mgr* %10 to void (%struct.jpeg_common_struct*)**
  %12 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %11, align 8, !tbaa !16
  tail call void %12(%struct.jpeg_common_struct* %cinfo) #5
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.then38, %if.end36
  %add33 = add i64 %add20, %div
  %call = tail call i8* @jpeg_get_small(%struct.jpeg_common_struct* %cinfo, i64 %add33) #5
  %cmp34 = icmp eq i8* %call, null
  br i1 %cmp34, label %if.end36, label %for.end.loopexit, !prof !40

for.end.loopexit:                                 ; preds = %for.cond.backedge
  %call.lcssa = phi i8* [ %call, %for.cond.backedge ]
  %add33.lcssa147 = phi i64 [ %add33, %for.cond.backedge ]
  %div.lcssa = phi i64 [ %div, %for.cond.backedge ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then19
  %.lcssa.in = phi i8* [ %call126, %if.then19 ], [ %call.lcssa, %for.end.loopexit ]
  %add33.lcssa = phi i64 [ %add33125, %if.then19 ], [ %add33.lcssa147, %for.end.loopexit ]
  %slop.1.lcssa = phi i64 [ %sub28.slop.0, %if.then19 ], [ %div.lcssa, %for.end.loopexit ]
  %.lcssa = bitcast i8* %.lcssa.in to %union.small_pool_struct*
  %total_space_allocated = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 5
  %13 = load i64, i64* %total_space_allocated, align 8, !tbaa !30
  %add41 = add i64 %13, %add33.lcssa
  store i64 %add41, i64* %total_space_allocated, align 8, !tbaa !30
  %add45 = add i64 %slop.1.lcssa, %sizeofobject.addr.0
  %bytes_left47 = getelementptr inbounds i8, i8* %.lcssa.in, i64 16
  %14 = bitcast i8* %bytes_left47 to i64*
  call void @llvm.memset.p0i8.i64(i8* nonnull %.lcssa.in, i8 0, i64 16, i32 8, i1 false)
  store i64 %add45, i64* %14, align 8, !tbaa !37
  br i1 %cmp21, label %if.then49, label %if.else53, !prof !41

if.then49:                                        ; preds = %for.end
  %15 = bitcast %union.small_pool_struct** %arrayidx12 to i8**
  store i8* %.lcssa.in, i8** %15, align 8, !tbaa !17
  br label %if.end57

if.else53:                                        ; preds = %for.end
  %16 = bitcast %union.small_pool_struct* %prev_hdr_ptr.0.lcssa to i8**
  store i8* %.lcssa.in, i8** %16, align 8, !tbaa !42
  br label %if.end57

if.end57.loopexit:                                ; preds = %while.body
  %hdr_ptr.0134.lcssa = phi %union.small_pool_struct* [ %hdr_ptr.0134, %while.body ]
  br label %if.end57

if.end57:                                         ; preds = %if.end57.loopexit, %if.then49, %if.else53
  %hdr_ptr.1 = phi %union.small_pool_struct* [ %.lcssa, %if.then49 ], [ %.lcssa, %if.else53 ], [ %hdr_ptr.0134.lcssa, %if.end57.loopexit ]
  %add.ptr = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %hdr_ptr.1, i64 1
  %17 = bitcast %union.small_pool_struct* %add.ptr to i8*
  %bytes_used59 = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %hdr_ptr.1, i64 0, i32 0, i32 1
  %18 = load i64, i64* %bytes_used59, align 8, !tbaa !43
  %add.ptr60 = getelementptr inbounds i8, i8* %17, i64 %18
  %add63 = add i64 %18, %sizeofobject.addr.0
  store i64 %add63, i64* %bytes_used59, align 8, !tbaa !43
  %bytes_left65 = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %hdr_ptr.1, i64 0, i32 0, i32 2
  %19 = load i64, i64* %bytes_left65, align 8, !tbaa !37
  %sub66 = sub i64 %19, %sizeofobject.addr.0
  store i64 %sub66, i64* %bytes_left65, align 8, !tbaa !37
  ret i8* %add.ptr60
}

; Function Attrs: nounwind uwtable
define internal i8* @alloc_large(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i64 %sizeofobject) #0 !prof !44 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp = icmp ugt i64 %sizeofobject, 999999976
  br i1 %cmp, label %if.then, label %if.end, !prof !45

if.then:                                          ; preds = %entry
  %err.i = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !12
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 53, i32* %msg_code.i, align 8, !tbaa !13
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
  store i32 3, i32* %arrayidx.i, align 4, !tbaa !15
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rem = and i64 %sizeofobject, 7
  %cmp2 = icmp eq i64 %rem, 0
  %sub = sub nsw i64 8, %rem
  %add = select i1 %cmp2, i64 0, i64 %sub
  %sizeofobject.addr.0 = add i64 %add, %sizeofobject
  %5 = icmp ugt i32 %pool_id, 1
  br i1 %5, label %if.then7, label %if.end11, !prof !46

if.then7:                                         ; preds = %if.end
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %6 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  store i32 12, i32* %msg_code, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
  store i32 %pool_id, i32* %arrayidx, align 4, !tbaa !15
  %7 = bitcast %struct.jpeg_error_mgr* %6 to void (%struct.jpeg_common_struct*)**
  %8 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %7, align 8, !tbaa !16
  tail call void %8(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then7
  %add12 = add i64 %sizeofobject.addr.0, 24
  %call = tail call i8* @jpeg_get_large(%struct.jpeg_common_struct* nonnull %cinfo, i64 %add12) #5
  %cmp13 = icmp eq i8* %call, null
  br i1 %cmp13, label %if.then14, label %if.end15, !prof !45

if.then14:                                        ; preds = %if.end11
  %err.i51 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %9 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i51, align 8, !tbaa !12
  %msg_code.i52 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 5
  store i32 53, i32* %msg_code.i52, align 8, !tbaa !13
  %arrayidx.i53 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 6, i32 0, i64 0
  store i32 4, i32* %arrayidx.i53, align 4, !tbaa !15
  %10 = bitcast %struct.jpeg_error_mgr* %9 to void (%struct.jpeg_common_struct*)**
  %11 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %10, align 8, !tbaa !16
  tail call void %11(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end11
  %total_space_allocated = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 5
  %12 = load i64, i64* %total_space_allocated, align 8, !tbaa !30
  %add17 = add i64 %12, %add12
  store i64 %add17, i64* %total_space_allocated, align 8, !tbaa !30
  %idxprom = sext i32 %pool_id to i64
  %arrayidx18 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 2, i64 %idxprom
  %13 = bitcast %union.large_pool_struct** %arrayidx18 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !17
  %15 = bitcast i8* %call to i64*
  store i64 %14, i64* %15, align 8, !tbaa !42
  %bytes_used = getelementptr inbounds i8, i8* %call, i64 8
  %16 = bitcast i8* %bytes_used to i64*
  store i64 %sizeofobject.addr.0, i64* %16, align 8, !tbaa !43
  %bytes_left = getelementptr inbounds i8, i8* %call, i64 16
  %17 = bitcast i8* %bytes_left to i64*
  store i64 0, i64* %17, align 8, !tbaa !37
  %18 = bitcast %union.large_pool_struct** %arrayidx18 to i8**
  store i8* %call, i8** %18, align 8, !tbaa !17
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 24
  ret i8* %add.ptr
}

; Function Attrs: nounwind uwtable
define internal i8** @alloc_sarray(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i32 %samplesperrow, i32 %numrows) #0 !prof !47 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %conv = zext i32 %samplesperrow to i64
  %div = udiv i64 999999976, %conv
  %cmp = icmp eq i64 %div, 0
  br i1 %cmp, label %if.then, label %if.end, !prof !48

if.then:                                          ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 69, i32* %msg_code, align 8, !tbaa !13
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv5 = zext i32 %numrows to i64
  %cmp6 = icmp ult i64 %div, %conv5
  %conv9 = trunc i64 %div to i32
  %rowsperchunk.0 = select i1 %cmp6, i32 %conv9, i32 %numrows
  %last_rowsperchunk = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 6
  store i32 %rowsperchunk.0, i32* %last_rowsperchunk, align 8, !tbaa !49
  %mul12 = shl nuw nsw i64 %conv5, 3
  %call = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 %pool_id, i64 %mul12)
  %5 = bitcast i8* %call to i8**
  %cmp1361 = icmp eq i32 %numrows, 0
  br i1 %cmp1361, label %while.end, label %while.body.preheader, !prof !50

while.body.preheader:                             ; preds = %if.end
  br label %while.body

while.cond.loopexit.loopexit:                     ; preds = %for.body
  %inc.lcssa = phi i32 [ %inc, %for.body ]
  br label %while.cond.loopexit

while.cond.loopexit:                              ; preds = %while.cond.loopexit.loopexit, %while.body
  %currow.1.lcssa = phi i32 [ %currow.063, %while.body ], [ %inc.lcssa, %while.cond.loopexit.loopexit ]
  %cmp13 = icmp ult i32 %currow.1.lcssa, %numrows
  br i1 %cmp13, label %while.body, label %while.end.loopexit, !prof !50

while.body:                                       ; preds = %while.body.preheader, %while.cond.loopexit
  %currow.063 = phi i32 [ %currow.1.lcssa, %while.cond.loopexit ], [ 0, %while.body.preheader ]
  %rowsperchunk.162 = phi i32 [ %rowsperchunk.1.sub, %while.cond.loopexit ], [ %rowsperchunk.0, %while.body.preheader ]
  %sub = sub i32 %numrows, %currow.063
  %cmp15 = icmp ult i32 %rowsperchunk.162, %sub
  %rowsperchunk.1.sub = select i1 %cmp15, i32 %rowsperchunk.162, i32 %sub
  %conv18 = zext i32 %rowsperchunk.1.sub to i64
  %mul20 = mul nuw i64 %conv18, %conv
  %call22 = tail call i8* @alloc_large(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i64 %mul20)
  %cmp2357 = icmp eq i32 %rowsperchunk.1.sub, 0
  br i1 %cmp2357, label %while.cond.loopexit, label %for.body.preheader, !prof !51

for.body.preheader:                               ; preds = %while.body
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %workspace.060 = phi i8* [ %add.ptr, %for.body ], [ %call22, %for.body.preheader ]
  %i.059 = phi i32 [ %dec, %for.body ], [ %rowsperchunk.1.sub, %for.body.preheader ]
  %currow.158 = phi i32 [ %inc, %for.body ], [ %currow.063, %for.body.preheader ]
  %inc = add i32 %currow.158, 1
  %idxprom = zext i32 %currow.158 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %5, i64 %idxprom
  store i8* %workspace.060, i8** %arrayidx, align 8, !tbaa !17
  %add.ptr = getelementptr inbounds i8, i8* %workspace.060, i64 %conv
  %dec = add i32 %i.059, -1
  %cmp23 = icmp eq i32 %dec, 0
  br i1 %cmp23, label %while.cond.loopexit.loopexit, label %for.body, !prof !51

while.end.loopexit:                               ; preds = %while.cond.loopexit
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %if.end
  ret i8** %5
}

; Function Attrs: nounwind uwtable
define internal [64 x i16]** @alloc_barray(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i32 %blocksperrow, i32 %numrows) #0 !prof !52 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %conv = zext i32 %blocksperrow to i64
  %mul = shl nuw nsw i64 %conv, 7
  %div = udiv i64 999999976, %mul
  %cmp = icmp eq i64 %div, 0
  br i1 %cmp, label %if.then, label %if.end, !prof !53

if.then:                                          ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 69, i32* %msg_code, align 8, !tbaa !13
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv5 = zext i32 %numrows to i64
  %cmp6 = icmp ult i64 %div, %conv5
  %conv9 = trunc i64 %div to i32
  %rowsperchunk.0 = select i1 %cmp6, i32 %conv9, i32 %numrows
  %last_rowsperchunk = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 6
  store i32 %rowsperchunk.0, i32* %last_rowsperchunk, align 8, !tbaa !49
  %mul12 = shl nuw nsw i64 %conv5, 3
  %call = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 %pool_id, i64 %mul12)
  %5 = bitcast i8* %call to [64 x i16]**
  %cmp1361 = icmp eq i32 %numrows, 0
  br i1 %cmp1361, label %while.end, label %while.body.preheader, !prof !54

while.body.preheader:                             ; preds = %if.end
  br label %while.body

while.cond.loopexit.loopexit:                     ; preds = %for.body
  %inc.lcssa = phi i32 [ %inc, %for.body ]
  br label %while.cond.loopexit

while.cond.loopexit:                              ; preds = %while.cond.loopexit.loopexit, %while.body
  %currow.1.lcssa = phi i32 [ %currow.063, %while.body ], [ %inc.lcssa, %while.cond.loopexit.loopexit ]
  %cmp13 = icmp ult i32 %currow.1.lcssa, %numrows
  br i1 %cmp13, label %while.body, label %while.end.loopexit, !prof !54

while.body:                                       ; preds = %while.body.preheader, %while.cond.loopexit
  %currow.063 = phi i32 [ %currow.1.lcssa, %while.cond.loopexit ], [ 0, %while.body.preheader ]
  %rowsperchunk.162 = phi i32 [ %rowsperchunk.1.sub, %while.cond.loopexit ], [ %rowsperchunk.0, %while.body.preheader ]
  %sub = sub i32 %numrows, %currow.063
  %cmp15 = icmp ult i32 %rowsperchunk.162, %sub
  %rowsperchunk.1.sub = select i1 %cmp15, i32 %rowsperchunk.162, i32 %sub
  %conv18 = zext i32 %rowsperchunk.1.sub to i64
  %mul21 = mul i64 %mul, %conv18
  %call22 = tail call i8* @alloc_large(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i64 %mul21)
  %cmp2357 = icmp eq i32 %rowsperchunk.1.sub, 0
  br i1 %cmp2357, label %while.cond.loopexit, label %for.body.preheader, !prof !55

for.body.preheader:                               ; preds = %while.body
  %6 = bitcast i8* %call22 to [64 x i16]*
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %workspace.060 = phi [64 x i16]* [ %add.ptr, %for.body ], [ %6, %for.body.preheader ]
  %i.059 = phi i32 [ %dec, %for.body ], [ %rowsperchunk.1.sub, %for.body.preheader ]
  %currow.158 = phi i32 [ %inc, %for.body ], [ %currow.063, %for.body.preheader ]
  %inc = add i32 %currow.158, 1
  %idxprom = zext i32 %currow.158 to i64
  %arrayidx = getelementptr inbounds [64 x i16]*, [64 x i16]** %5, i64 %idxprom
  store [64 x i16]* %workspace.060, [64 x i16]** %arrayidx, align 8, !tbaa !17
  %add.ptr = getelementptr inbounds [64 x i16], [64 x i16]* %workspace.060, i64 %conv
  %dec = add i32 %i.059, -1
  %cmp23 = icmp eq i32 %dec, 0
  br i1 %cmp23, label %while.cond.loopexit.loopexit, label %for.body, !prof !55

while.end.loopexit:                               ; preds = %while.cond.loopexit
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %if.end
  ret [64 x i16]** %5
}

; Function Attrs: nounwind uwtable
define internal %struct.jvirt_sarray_control* @request_virt_sarray(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i32 %pre_zero, i32 %samplesperrow, i32 %numrows, i32 %maxaccess) #0 !prof !56 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp = icmp eq i32 %pool_id, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 12, i32* %msg_code, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
  store i32 %pool_id, i32* %arrayidx, align 4, !tbaa !15
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 %pool_id, i64 152)
  %5 = bitcast i8* %call to %struct.jvirt_sarray_control*
  %mem_buffer = bitcast i8* %call to i8***
  store i8** null, i8*** %mem_buffer, align 8, !tbaa !57
  %rows_in_array = getelementptr inbounds i8, i8* %call, i64 8
  %6 = bitcast i8* %rows_in_array to i32*
  store i32 %numrows, i32* %6, align 8, !tbaa !60
  %samplesperrow5 = getelementptr inbounds i8, i8* %call, i64 12
  %7 = bitcast i8* %samplesperrow5 to i32*
  store i32 %samplesperrow, i32* %7, align 4, !tbaa !61
  %maxaccess6 = getelementptr inbounds i8, i8* %call, i64 16
  %8 = bitcast i8* %maxaccess6 to i32*
  store i32 %maxaccess, i32* %8, align 8, !tbaa !62
  %pre_zero7 = getelementptr inbounds i8, i8* %call, i64 36
  %9 = bitcast i8* %pre_zero7 to i32*
  store i32 %pre_zero, i32* %9, align 4, !tbaa !63
  %b_s_open = getelementptr inbounds i8, i8* %call, i64 44
  %10 = bitcast i8* %b_s_open to i32*
  store i32 0, i32* %10, align 4, !tbaa !64
  %virt_sarray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 3
  %11 = bitcast %struct.jvirt_sarray_control** %virt_sarray_list to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !65
  %next = getelementptr inbounds i8, i8* %call, i64 48
  %13 = bitcast i8* %next to i64*
  store i64 %12, i64* %13, align 8, !tbaa !66
  %14 = bitcast %struct.jvirt_sarray_control** %virt_sarray_list to i8**
  store i8* %call, i8** %14, align 8, !tbaa !65
  ret %struct.jvirt_sarray_control* %5
}

; Function Attrs: nounwind uwtable
define internal %struct.jvirt_barray_control* @request_virt_barray(%struct.jpeg_common_struct* %cinfo, i32 %pool_id, i32 %pre_zero, i32 %blocksperrow, i32 %numrows, i32 %maxaccess) #0 !prof !52 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp = icmp eq i32 %pool_id, 1
  br i1 %cmp, label %if.end, label %if.then, !prof !67

if.then:                                          ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  store i32 12, i32* %msg_code, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
  store i32 %pool_id, i32* %arrayidx, align 4, !tbaa !15
  %3 = bitcast %struct.jpeg_error_mgr* %2 to void (%struct.jpeg_common_struct*)**
  %4 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %3, align 8, !tbaa !16
  tail call void %4(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 %pool_id, i64 152)
  %5 = bitcast i8* %call to %struct.jvirt_barray_control*
  %mem_buffer = bitcast i8* %call to [64 x i16]***
  store [64 x i16]** null, [64 x i16]*** %mem_buffer, align 8, !tbaa !68
  %rows_in_array = getelementptr inbounds i8, i8* %call, i64 8
  %6 = bitcast i8* %rows_in_array to i32*
  store i32 %numrows, i32* %6, align 8, !tbaa !70
  %blocksperrow5 = getelementptr inbounds i8, i8* %call, i64 12
  %7 = bitcast i8* %blocksperrow5 to i32*
  store i32 %blocksperrow, i32* %7, align 4, !tbaa !71
  %maxaccess6 = getelementptr inbounds i8, i8* %call, i64 16
  %8 = bitcast i8* %maxaccess6 to i32*
  store i32 %maxaccess, i32* %8, align 8, !tbaa !72
  %pre_zero7 = getelementptr inbounds i8, i8* %call, i64 36
  %9 = bitcast i8* %pre_zero7 to i32*
  store i32 %pre_zero, i32* %9, align 4, !tbaa !73
  %b_s_open = getelementptr inbounds i8, i8* %call, i64 44
  %10 = bitcast i8* %b_s_open to i32*
  store i32 0, i32* %10, align 4, !tbaa !74
  %virt_barray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 4
  %11 = bitcast %struct.jvirt_barray_control** %virt_barray_list to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !75
  %next = getelementptr inbounds i8, i8* %call, i64 48
  %13 = bitcast i8* %next to i64*
  store i64 %12, i64* %13, align 8, !tbaa !76
  %14 = bitcast %struct.jvirt_barray_control** %virt_barray_list to i8**
  store i8* %call, i8** %14, align 8, !tbaa !75
  ret %struct.jvirt_barray_control* %5
}

; Function Attrs: nounwind uwtable
define internal void @realize_virt_arrays(%struct.jpeg_common_struct* %cinfo) #0 !prof !2 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %virt_sarray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 3
  %sptr.0308 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %virt_sarray_list, align 8, !tbaa !17
  %cmp309 = icmp eq %struct.jvirt_sarray_control* %sptr.0308, null
  br i1 %cmp309, label %for.end, label %for.body.preheader, !prof !31

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %sptr.0312 = phi %struct.jvirt_sarray_control* [ %sptr.0, %for.inc ], [ %sptr.0308, %for.body.preheader ]
  %space_per_minheight.0311 = phi i64 [ %space_per_minheight.1, %for.inc ], [ 0, %for.body.preheader ]
  %maximum_space.0310 = phi i64 [ %maximum_space.1, %for.inc ], [ 0, %for.body.preheader ]
  %mem_buffer = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0312, i64 0, i32 0
  %2 = load i8**, i8*** %mem_buffer, align 8, !tbaa !57
  %cmp2 = icmp eq i8** %2, null
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %maxaccess = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0312, i64 0, i32 3
  %3 = load i32, i32* %maxaccess, align 8, !tbaa !62
  %conv = zext i32 %3 to i64
  %samplesperrow = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0312, i64 0, i32 2
  %4 = load i32, i32* %samplesperrow, align 4, !tbaa !61
  %conv3 = zext i32 %4 to i64
  %mul = mul nuw nsw i64 %conv3, %conv
  %add = add i64 %mul, %space_per_minheight.0311
  %rows_in_array = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0312, i64 0, i32 1
  %5 = load i32, i32* %rows_in_array, align 8, !tbaa !60
  %conv5 = zext i32 %5 to i64
  %mul8 = mul nuw nsw i64 %conv5, %conv3
  %add10 = add i64 %mul8, %maximum_space.0310
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %maximum_space.1 = phi i64 [ %add10, %if.then ], [ %maximum_space.0310, %for.body ]
  %space_per_minheight.1 = phi i64 [ %add, %if.then ], [ %space_per_minheight.0311, %for.body ]
  %next = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0312, i64 0, i32 11
  %sptr.0 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %next, align 8, !tbaa !17
  %cmp = icmp eq %struct.jvirt_sarray_control* %sptr.0, null
  br i1 %cmp, label %for.end.loopexit, label %for.body, !prof !31

for.end.loopexit:                                 ; preds = %for.inc
  %space_per_minheight.1.lcssa = phi i64 [ %space_per_minheight.1, %for.inc ]
  %maximum_space.1.lcssa = phi i64 [ %maximum_space.1, %for.inc ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %space_per_minheight.0.lcssa = phi i64 [ 0, %entry ], [ %space_per_minheight.1.lcssa, %for.end.loopexit ]
  %maximum_space.0.lcssa = phi i64 [ 0, %entry ], [ %maximum_space.1.lcssa, %for.end.loopexit ]
  %virt_barray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 4
  %bptr.0302 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %virt_barray_list, align 8, !tbaa !17
  %cmp12303 = icmp eq %struct.jvirt_barray_control* %bptr.0302, null
  br i1 %cmp12303, label %for.end35, label %for.body14.preheader, !prof !77

for.body14.preheader:                             ; preds = %for.end
  br label %for.body14

for.body14:                                       ; preds = %for.body14.preheader, %for.inc33
  %bptr.0306 = phi %struct.jvirt_barray_control* [ %bptr.0, %for.inc33 ], [ %bptr.0302, %for.body14.preheader ]
  %space_per_minheight.2305 = phi i64 [ %space_per_minheight.3, %for.inc33 ], [ %space_per_minheight.0.lcssa, %for.body14.preheader ]
  %maximum_space.2304 = phi i64 [ %maximum_space.3, %for.inc33 ], [ %maximum_space.0.lcssa, %for.body14.preheader ]
  %mem_buffer15 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0306, i64 0, i32 0
  %6 = load [64 x i16]**, [64 x i16]*** %mem_buffer15, align 8, !tbaa !68
  %cmp16 = icmp eq [64 x i16]** %6, null
  br i1 %cmp16, label %if.then18, label %for.inc33, !prof !67

if.then18:                                        ; preds = %for.body14
  %maxaccess19 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0306, i64 0, i32 3
  %7 = load i32, i32* %maxaccess19, align 8, !tbaa !72
  %conv20 = zext i32 %7 to i64
  %blocksperrow = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0306, i64 0, i32 2
  %8 = load i32, i32* %blocksperrow, align 4, !tbaa !71
  %conv21 = zext i32 %8 to i64
  %mul22 = shl nuw nsw i64 %conv20, 7
  %mul23 = mul i64 %mul22, %conv21
  %add24 = add i64 %mul23, %space_per_minheight.2305
  %rows_in_array25 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0306, i64 0, i32 1
  %9 = load i32, i32* %rows_in_array25, align 8, !tbaa !70
  %conv26 = zext i32 %9 to i64
  %mul29 = shl nuw nsw i64 %conv21, 7
  %mul30 = mul i64 %mul29, %conv26
  %add31 = add i64 %mul30, %maximum_space.2304
  br label %for.inc33

for.inc33:                                        ; preds = %for.body14, %if.then18
  %maximum_space.3 = phi i64 [ %add31, %if.then18 ], [ %maximum_space.2304, %for.body14 ]
  %space_per_minheight.3 = phi i64 [ %add24, %if.then18 ], [ %space_per_minheight.2305, %for.body14 ]
  %next34 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0306, i64 0, i32 11
  %bptr.0 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %next34, align 8, !tbaa !17
  %cmp12 = icmp eq %struct.jvirt_barray_control* %bptr.0, null
  br i1 %cmp12, label %for.end35.loopexit, label %for.body14, !prof !77

for.end35.loopexit:                               ; preds = %for.inc33
  %space_per_minheight.3.lcssa = phi i64 [ %space_per_minheight.3, %for.inc33 ]
  %maximum_space.3.lcssa = phi i64 [ %maximum_space.3, %for.inc33 ]
  br label %for.end35

for.end35:                                        ; preds = %for.end35.loopexit, %for.end
  %space_per_minheight.2.lcssa = phi i64 [ %space_per_minheight.0.lcssa, %for.end ], [ %space_per_minheight.3.lcssa, %for.end35.loopexit ]
  %maximum_space.2.lcssa = phi i64 [ %maximum_space.0.lcssa, %for.end ], [ %maximum_space.3.lcssa, %for.end35.loopexit ]
  %cmp36 = icmp slt i64 %space_per_minheight.2.lcssa, 1
  br i1 %cmp36, label %cleanup, label %if.end39, !prof !11

if.end39:                                         ; preds = %for.end35
  %total_space_allocated = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 5
  %10 = load i64, i64* %total_space_allocated, align 8, !tbaa !30
  %call = tail call i64 @jpeg_mem_available(%struct.jpeg_common_struct* %cinfo, i64 %space_per_minheight.2.lcssa, i64 %maximum_space.2.lcssa, i64 %10) #5
  %cmp40 = icmp slt i64 %call, %maximum_space.2.lcssa
  br i1 %cmp40, label %if.else, label %if.end47, !prof !11

if.else:                                          ; preds = %if.end39
  %div = sdiv i64 %call, %space_per_minheight.2.lcssa
  %cmp43 = icmp slt i64 %div, 1
  %.div = select i1 %cmp43, i64 1, i64 %div
  br label %if.end47

if.end47:                                         ; preds = %if.end39, %if.else
  %max_minheights.0 = phi i64 [ %.div, %if.else ], [ 1000000000, %if.end39 ]
  %sptr.1298 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %virt_sarray_list, align 8, !tbaa !17
  %cmp50299 = icmp eq %struct.jvirt_sarray_control* %sptr.1298, null
  br i1 %cmp50299, label %for.cond89.preheader, label %for.body52.lr.ph, !prof !31

for.body52.lr.ph:                                 ; preds = %if.end47
  %err.i = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %last_rowsperchunk = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 6
  br label %for.body52

for.cond89.preheader.loopexit:                    ; preds = %for.inc85
  br label %for.cond89.preheader

for.cond89.preheader:                             ; preds = %for.cond89.preheader.loopexit, %if.end47
  %bptr.1294 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %virt_barray_list, align 8, !tbaa !17
  %cmp90295 = icmp eq %struct.jvirt_barray_control* %bptr.1294, null
  br i1 %cmp90295, label %cleanup, label %for.body92.lr.ph, !prof !77

for.body92.lr.ph:                                 ; preds = %for.cond89.preheader
  %err.i240 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %last_rowsperchunk128 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 6
  br label %for.body92

for.body52:                                       ; preds = %for.body52.lr.ph, %for.inc85
  %sptr.1300 = phi %struct.jvirt_sarray_control* [ %sptr.1298, %for.body52.lr.ph ], [ %sptr.1, %for.inc85 ]
  %mem_buffer53 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 0
  %11 = load i8**, i8*** %mem_buffer53, align 8, !tbaa !57
  %cmp54 = icmp eq i8** %11, null
  br i1 %cmp54, label %if.then56, label %for.inc85

if.then56:                                        ; preds = %for.body52
  %rows_in_array57 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 1
  %12 = bitcast i32* %rows_in_array57 to i64*
  %13 = load i64, i64* %12, align 8
  %14 = trunc i64 %13 to i32
  %conv58 = and i64 %13, 4294967295
  %sub = add nsw i64 %conv58, -1
  %maxaccess59 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 3
  %15 = load i32, i32* %maxaccess59, align 8, !tbaa !62
  %conv60 = zext i32 %15 to i64
  %div61 = sdiv i64 %sub, %conv60
  %cmp63 = icmp slt i64 %div61, %max_minheights.0
  %16 = lshr i64 %13, 32
  br i1 %cmp63, label %if.then65, label %if.else67

if.then65:                                        ; preds = %if.then56
  %17 = trunc i64 %16 to i32
  %rows_in_mem = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 4
  store i32 %14, i32* %rows_in_mem, align 4, !tbaa !78
  br label %if.end79

if.else67:                                        ; preds = %if.then56
  %mul70 = mul nsw i64 %conv60, %max_minheights.0
  %conv71 = trunc i64 %mul70 to i32
  %rows_in_mem72 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 4
  store i32 %conv71, i32* %rows_in_mem72, align 4, !tbaa !78
  %b_s_info = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 12
  %samplesperrow75 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 2
  %mul77 = mul nuw nsw i64 %16, %conv58
  tail call void @jpeg_open_backing_store(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* %b_s_info, i64 %mul77) #5
  %b_s_open = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 10
  store i32 1, i32* %b_s_open, align 4, !tbaa !64
  %.pre = load i32, i32* %samplesperrow75, align 4, !tbaa !61
  %.pre315 = load i32, i32* %rows_in_mem72, align 4, !tbaa !78
  br label %if.end79

if.end79:                                         ; preds = %if.else67, %if.then65
  %18 = phi i32 [ %.pre315, %if.else67 ], [ %14, %if.then65 ]
  %19 = phi i32 [ %.pre, %if.else67 ], [ %17, %if.then65 ]
  %20 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %conv.i = zext i32 %19 to i64
  %div.i = udiv i64 999999976, %conv.i
  %cmp.i = icmp eq i64 %div.i, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i, !prof !48

if.then.i:                                        ; preds = %if.end79
  %21 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !12
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 5
  store i32 69, i32* %msg_code.i, align 8, !tbaa !13
  %22 = bitcast %struct.jpeg_error_mgr* %21 to void (%struct.jpeg_common_struct*)**
  %23 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %22, align 8, !tbaa !16
  tail call void %23(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end79
  %conv5.i = zext i32 %18 to i64
  %cmp6.i = icmp ult i64 %div.i, %conv5.i
  %conv9.i = trunc i64 %div.i to i32
  %rowsperchunk.0.i = select i1 %cmp6.i, i32 %conv9.i, i32 %18
  %last_rowsperchunk.i = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %20, i64 0, i32 6
  store i32 %rowsperchunk.0.i, i32* %last_rowsperchunk.i, align 8, !tbaa !49
  %mul12.i = shl nuw nsw i64 %conv5.i, 3
  %call.i = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 1, i64 %mul12.i) #5
  %24 = bitcast i8* %call.i to i8**
  %cmp1361.i = icmp eq i32 %18, 0
  br i1 %cmp1361.i, label %alloc_sarray.exit, label %while.body.i.preheader, !prof !50

while.body.i.preheader:                           ; preds = %if.end.i
  br label %while.body.i

while.cond.loopexit.i.loopexit:                   ; preds = %for.body.i
  %inc.i.lcssa = phi i32 [ %inc.i, %for.body.i ]
  br label %while.cond.loopexit.i

while.cond.loopexit.i:                            ; preds = %while.cond.loopexit.i.loopexit, %alloc_large.exit
  %currow.1.lcssa.i = phi i32 [ %currow.063.i, %alloc_large.exit ], [ %inc.i.lcssa, %while.cond.loopexit.i.loopexit ]
  %cmp13.i = icmp ult i32 %currow.1.lcssa.i, %18
  br i1 %cmp13.i, label %while.body.i, label %alloc_sarray.exit.loopexit, !prof !50

while.body.i:                                     ; preds = %while.body.i.preheader, %while.cond.loopexit.i
  %currow.063.i = phi i32 [ %currow.1.lcssa.i, %while.cond.loopexit.i ], [ 0, %while.body.i.preheader ]
  %rowsperchunk.162.i = phi i32 [ %rowsperchunk.1.sub.i, %while.cond.loopexit.i ], [ %rowsperchunk.0.i, %while.body.i.preheader ]
  %sub.i = sub i32 %18, %currow.063.i
  %cmp15.i = icmp ult i32 %rowsperchunk.162.i, %sub.i
  %rowsperchunk.1.sub.i = select i1 %cmp15.i, i32 %rowsperchunk.162.i, i32 %sub.i
  %conv18.i = zext i32 %rowsperchunk.1.sub.i to i64
  %mul20.i = mul nuw i64 %conv18.i, %conv.i
  %25 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp.i229 = icmp ugt i64 %mul20.i, 999999976
  br i1 %cmp.i229, label %if.then.i230, label %if.end.i232, !prof !45

if.then.i230:                                     ; preds = %while.body.i
  %26 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !12
  %msg_code.i.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %26, i64 0, i32 5
  store i32 53, i32* %msg_code.i.i, align 8, !tbaa !13
  %arrayidx.i.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %26, i64 0, i32 6, i32 0, i64 0
  store i32 3, i32* %arrayidx.i.i, align 4, !tbaa !15
  %27 = bitcast %struct.jpeg_error_mgr* %26 to void (%struct.jpeg_common_struct*)**
  %28 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %27, align 8, !tbaa !16
  tail call void %28(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end.i232

if.end.i232:                                      ; preds = %if.then.i230, %while.body.i
  %rem.i = and i64 %mul20.i, 7
  %cmp2.i = icmp eq i64 %rem.i, 0
  %sub.i231 = sub nsw i64 8, %rem.i
  %add.i = select i1 %cmp2.i, i64 0, i64 %sub.i231
  %sizeofobject.addr.0.i = add i64 %add.i, %mul20.i
  %add12.i = add i64 %sizeofobject.addr.0.i, 24
  %call.i233 = tail call i8* @jpeg_get_large(%struct.jpeg_common_struct* nonnull %cinfo, i64 %add12.i) #5
  %cmp13.i234 = icmp eq i8* %call.i233, null
  br i1 %cmp13.i234, label %if.then14.i, label %alloc_large.exit, !prof !45

if.then14.i:                                      ; preds = %if.end.i232
  %29 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !12
  %msg_code.i52.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %29, i64 0, i32 5
  store i32 53, i32* %msg_code.i52.i, align 8, !tbaa !13
  %arrayidx.i53.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %29, i64 0, i32 6, i32 0, i64 0
  store i32 4, i32* %arrayidx.i53.i, align 4, !tbaa !15
  %30 = bitcast %struct.jpeg_error_mgr* %29 to void (%struct.jpeg_common_struct*)**
  %31 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %30, align 8, !tbaa !16
  tail call void %31(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %alloc_large.exit

alloc_large.exit:                                 ; preds = %if.end.i232, %if.then14.i
  %total_space_allocated.i = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %25, i64 0, i32 5
  %32 = load i64, i64* %total_space_allocated.i, align 8, !tbaa !30
  %add17.i = add i64 %32, %add12.i
  store i64 %add17.i, i64* %total_space_allocated.i, align 8, !tbaa !30
  %arrayidx18.i = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %25, i64 0, i32 2, i64 1
  %33 = bitcast %union.large_pool_struct** %arrayidx18.i to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !17
  %35 = bitcast i8* %call.i233 to i64*
  store i64 %34, i64* %35, align 8, !tbaa !42
  %bytes_used.i = getelementptr inbounds i8, i8* %call.i233, i64 8
  %36 = bitcast i8* %bytes_used.i to i64*
  store i64 %sizeofobject.addr.0.i, i64* %36, align 8, !tbaa !43
  %bytes_left.i = getelementptr inbounds i8, i8* %call.i233, i64 16
  %37 = bitcast i8* %bytes_left.i to i64*
  store i64 0, i64* %37, align 8, !tbaa !37
  %38 = bitcast %union.large_pool_struct** %arrayidx18.i to i8**
  store i8* %call.i233, i8** %38, align 8, !tbaa !17
  %cmp2357.i = icmp eq i32 %rowsperchunk.1.sub.i, 0
  br i1 %cmp2357.i, label %while.cond.loopexit.i, label %for.body.i.preheader, !prof !51

for.body.i.preheader:                             ; preds = %alloc_large.exit
  %add.ptr.i235 = getelementptr inbounds i8, i8* %call.i233, i64 24
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i.preheader, %for.body.i
  %workspace.060.i = phi i8* [ %add.ptr.i, %for.body.i ], [ %add.ptr.i235, %for.body.i.preheader ]
  %i.059.i = phi i32 [ %dec.i, %for.body.i ], [ %rowsperchunk.1.sub.i, %for.body.i.preheader ]
  %currow.158.i = phi i32 [ %inc.i, %for.body.i ], [ %currow.063.i, %for.body.i.preheader ]
  %inc.i = add i32 %currow.158.i, 1
  %idxprom.i = zext i32 %currow.158.i to i64
  %arrayidx.i = getelementptr inbounds i8*, i8** %24, i64 %idxprom.i
  store i8* %workspace.060.i, i8** %arrayidx.i, align 8, !tbaa !17
  %add.ptr.i = getelementptr inbounds i8, i8* %workspace.060.i, i64 %conv.i
  %dec.i = add i32 %i.059.i, -1
  %cmp23.i = icmp eq i32 %dec.i, 0
  br i1 %cmp23.i, label %while.cond.loopexit.i.loopexit, label %for.body.i, !prof !51

alloc_sarray.exit.loopexit:                       ; preds = %while.cond.loopexit.i
  br label %alloc_sarray.exit

alloc_sarray.exit:                                ; preds = %alloc_sarray.exit.loopexit, %if.end.i
  %39 = bitcast %struct.jvirt_sarray_control* %sptr.1300 to i8**
  store i8* %call.i, i8** %39, align 8, !tbaa !57
  %40 = load i32, i32* %last_rowsperchunk, align 8, !tbaa !49
  %rowsperchunk = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 5
  store i32 %40, i32* %rowsperchunk, align 8, !tbaa !79
  %cur_start_row = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 6
  store i32 0, i32* %cur_start_row, align 4, !tbaa !80
  %first_undef_row = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 7
  store i32 0, i32* %first_undef_row, align 8, !tbaa !81
  %dirty = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 9
  store i32 0, i32* %dirty, align 8, !tbaa !82
  br label %for.inc85

for.inc85:                                        ; preds = %for.body52, %alloc_sarray.exit
  %next86 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.1300, i64 0, i32 11
  %sptr.1 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %next86, align 8, !tbaa !17
  %cmp50 = icmp eq %struct.jvirt_sarray_control* %sptr.1, null
  br i1 %cmp50, label %for.cond89.preheader.loopexit, label %for.body52, !prof !31

for.body92:                                       ; preds = %for.body92.lr.ph, %for.inc134
  %bptr.1296 = phi %struct.jvirt_barray_control* [ %bptr.1294, %for.body92.lr.ph ], [ %bptr.1, %for.inc134 ]
  %mem_buffer93 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 0
  %41 = load [64 x i16]**, [64 x i16]*** %mem_buffer93, align 8, !tbaa !68
  %cmp94 = icmp eq [64 x i16]** %41, null
  br i1 %cmp94, label %if.then96, label %for.inc134, !prof !67

if.then96:                                        ; preds = %for.body92
  %rows_in_array97 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 1
  %42 = bitcast i32* %rows_in_array97 to i64*
  %43 = load i64, i64* %42, align 8
  %44 = trunc i64 %43 to i32
  %conv98 = and i64 %43, 4294967295
  %sub99 = add nsw i64 %conv98, -1
  %maxaccess100 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 3
  %45 = load i32, i32* %maxaccess100, align 8, !tbaa !72
  %conv101 = zext i32 %45 to i64
  %div102 = sdiv i64 %sub99, %conv101
  %cmp104 = icmp slt i64 %div102, %max_minheights.0
  %46 = lshr i64 %43, 32
  br i1 %cmp104, label %if.then106, label %if.else109, !prof !67

if.then106:                                       ; preds = %if.then96
  %47 = trunc i64 %46 to i32
  %rows_in_mem108 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 4
  store i32 %44, i32* %rows_in_mem108, align 4, !tbaa !83
  br label %if.end123

if.else109:                                       ; preds = %if.then96
  %mul112 = mul nsw i64 %conv101, %max_minheights.0
  %conv113 = trunc i64 %mul112 to i32
  %rows_in_mem114 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 4
  store i32 %conv113, i32* %rows_in_mem114, align 4, !tbaa !83
  %b_s_info115 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 12
  %blocksperrow118 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 2
  %mul120 = shl nuw nsw i64 %conv98, 7
  %mul121 = mul i64 %mul120, %46
  tail call void @jpeg_open_backing_store(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* %b_s_info115, i64 %mul121) #5
  %b_s_open122 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 10
  store i32 1, i32* %b_s_open122, align 4, !tbaa !74
  %.pre316 = load i32, i32* %blocksperrow118, align 4, !tbaa !71
  %.pre317 = load i32, i32* %rows_in_mem114, align 4, !tbaa !83
  br label %if.end123

if.end123:                                        ; preds = %if.else109, %if.then106
  %48 = phi i32 [ %.pre317, %if.else109 ], [ %44, %if.then106 ]
  %49 = phi i32 [ %.pre316, %if.else109 ], [ %47, %if.then106 ]
  %50 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %conv.i237 = zext i32 %49 to i64
  %mul.i = shl nuw nsw i64 %conv.i237, 7
  %div.i238 = udiv i64 999999976, %mul.i
  %cmp.i239 = icmp eq i64 %div.i238, 0
  br i1 %cmp.i239, label %if.then.i242, label %if.end.i251, !prof !53

if.then.i242:                                     ; preds = %if.end123
  %51 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i240, align 8, !tbaa !12
  %msg_code.i241 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %51, i64 0, i32 5
  store i32 69, i32* %msg_code.i241, align 8, !tbaa !13
  %52 = bitcast %struct.jpeg_error_mgr* %51 to void (%struct.jpeg_common_struct*)**
  %53 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %52, align 8, !tbaa !16
  tail call void %53(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end.i251

if.end.i251:                                      ; preds = %if.then.i242, %if.end123
  %conv5.i243 = zext i32 %48 to i64
  %cmp6.i244 = icmp ult i64 %div.i238, %conv5.i243
  %conv9.i245 = trunc i64 %div.i238 to i32
  %rowsperchunk.0.i246 = select i1 %cmp6.i244, i32 %conv9.i245, i32 %48
  %last_rowsperchunk.i247 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %50, i64 0, i32 6
  store i32 %rowsperchunk.0.i246, i32* %last_rowsperchunk.i247, align 8, !tbaa !49
  %mul12.i248 = shl nuw nsw i64 %conv5.i243, 3
  %call.i249 = tail call i8* @alloc_small(%struct.jpeg_common_struct* nonnull %cinfo, i32 1, i64 %mul12.i248) #5
  %54 = bitcast i8* %call.i249 to [64 x i16]**
  %cmp1361.i250 = icmp eq i32 %48, 0
  br i1 %cmp1361.i250, label %alloc_barray.exit, label %while.body.i262.preheader, !prof !54

while.body.i262.preheader:                        ; preds = %if.end.i251
  br label %while.body.i262

while.cond.loopexit.i254.loopexit:                ; preds = %for.body.i272
  %inc.i266.lcssa = phi i32 [ %inc.i266, %for.body.i272 ]
  br label %while.cond.loopexit.i254

while.cond.loopexit.i254:                         ; preds = %while.cond.loopexit.i254.loopexit, %alloc_large.exit293
  %currow.1.lcssa.i252 = phi i32 [ %currow.063.i255, %alloc_large.exit293 ], [ %inc.i266.lcssa, %while.cond.loopexit.i254.loopexit ]
  %cmp13.i253 = icmp ult i32 %currow.1.lcssa.i252, %48
  br i1 %cmp13.i253, label %while.body.i262, label %alloc_barray.exit.loopexit, !prof !54

while.body.i262:                                  ; preds = %while.body.i262.preheader, %while.cond.loopexit.i254
  %currow.063.i255 = phi i32 [ %currow.1.lcssa.i252, %while.cond.loopexit.i254 ], [ 0, %while.body.i262.preheader ]
  %rowsperchunk.162.i256 = phi i32 [ %rowsperchunk.1.sub.i259, %while.cond.loopexit.i254 ], [ %rowsperchunk.0.i246, %while.body.i262.preheader ]
  %sub.i257 = sub i32 %48, %currow.063.i255
  %cmp15.i258 = icmp ult i32 %rowsperchunk.162.i256, %sub.i257
  %rowsperchunk.1.sub.i259 = select i1 %cmp15.i258, i32 %rowsperchunk.162.i256, i32 %sub.i257
  %conv18.i260 = zext i32 %rowsperchunk.1.sub.i259 to i64
  %mul21.i = mul i64 %conv18.i260, %mul.i
  %55 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %cmp.i274 = icmp ugt i64 %mul21.i, 999999976
  br i1 %cmp.i274, label %if.then.i278, label %if.end.i279, !prof !45

if.then.i278:                                     ; preds = %while.body.i262
  %56 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i240, align 8, !tbaa !12
  %msg_code.i.i276 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %56, i64 0, i32 5
  store i32 53, i32* %msg_code.i.i276, align 8, !tbaa !13
  %arrayidx.i.i277 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %56, i64 0, i32 6, i32 0, i64 0
  store i32 3, i32* %arrayidx.i.i277, align 4, !tbaa !15
  %57 = bitcast %struct.jpeg_error_mgr* %56 to void (%struct.jpeg_common_struct*)**
  %58 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %57, align 8, !tbaa !16
  tail call void %58(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end.i279

if.end.i279:                                      ; preds = %if.then.i278, %while.body.i262
  %add12.i280 = or i64 %mul21.i, 24
  %call.i281 = tail call i8* @jpeg_get_large(%struct.jpeg_common_struct* nonnull %cinfo, i64 %add12.i280) #5
  %cmp13.i282 = icmp eq i8* %call.i281, null
  br i1 %cmp13.i282, label %if.then14.i286, label %alloc_large.exit293, !prof !45

if.then14.i286:                                   ; preds = %if.end.i279
  %59 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i240, align 8, !tbaa !12
  %msg_code.i52.i284 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %59, i64 0, i32 5
  store i32 53, i32* %msg_code.i52.i284, align 8, !tbaa !13
  %arrayidx.i53.i285 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %59, i64 0, i32 6, i32 0, i64 0
  store i32 4, i32* %arrayidx.i53.i285, align 4, !tbaa !15
  %60 = bitcast %struct.jpeg_error_mgr* %59 to void (%struct.jpeg_common_struct*)**
  %61 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %60, align 8, !tbaa !16
  tail call void %61(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %alloc_large.exit293

alloc_large.exit293:                              ; preds = %if.end.i279, %if.then14.i286
  %total_space_allocated.i287 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %55, i64 0, i32 5
  %62 = load i64, i64* %total_space_allocated.i287, align 8, !tbaa !30
  %add17.i288 = add i64 %62, %add12.i280
  store i64 %add17.i288, i64* %total_space_allocated.i287, align 8, !tbaa !30
  %arrayidx18.i289 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %55, i64 0, i32 2, i64 1
  %63 = bitcast %union.large_pool_struct** %arrayidx18.i289 to i64*
  %64 = load i64, i64* %63, align 8, !tbaa !17
  %65 = bitcast i8* %call.i281 to i64*
  store i64 %64, i64* %65, align 8, !tbaa !42
  %bytes_used.i290 = getelementptr inbounds i8, i8* %call.i281, i64 8
  %66 = bitcast i8* %bytes_used.i290 to i64*
  store i64 %mul21.i, i64* %66, align 8, !tbaa !43
  %bytes_left.i291 = getelementptr inbounds i8, i8* %call.i281, i64 16
  %67 = bitcast i8* %bytes_left.i291 to i64*
  store i64 0, i64* %67, align 8, !tbaa !37
  %68 = bitcast %union.large_pool_struct** %arrayidx18.i289 to i8**
  store i8* %call.i281, i8** %68, align 8, !tbaa !17
  %cmp2357.i261 = icmp eq i32 %rowsperchunk.1.sub.i259, 0
  br i1 %cmp2357.i261, label %while.cond.loopexit.i254, label %for.body.preheader.i, !prof !55

for.body.preheader.i:                             ; preds = %alloc_large.exit293
  %add.ptr.i292 = getelementptr inbounds i8, i8* %call.i281, i64 24
  %69 = bitcast i8* %add.ptr.i292 to [64 x i16]*
  br label %for.body.i272

for.body.i272:                                    ; preds = %for.body.i272, %for.body.preheader.i
  %workspace.060.i263 = phi [64 x i16]* [ %add.ptr.i269, %for.body.i272 ], [ %69, %for.body.preheader.i ]
  %i.059.i264 = phi i32 [ %dec.i270, %for.body.i272 ], [ %rowsperchunk.1.sub.i259, %for.body.preheader.i ]
  %currow.158.i265 = phi i32 [ %inc.i266, %for.body.i272 ], [ %currow.063.i255, %for.body.preheader.i ]
  %inc.i266 = add i32 %currow.158.i265, 1
  %idxprom.i267 = zext i32 %currow.158.i265 to i64
  %arrayidx.i268 = getelementptr inbounds [64 x i16]*, [64 x i16]** %54, i64 %idxprom.i267
  store [64 x i16]* %workspace.060.i263, [64 x i16]** %arrayidx.i268, align 8, !tbaa !17
  %add.ptr.i269 = getelementptr inbounds [64 x i16], [64 x i16]* %workspace.060.i263, i64 %conv.i237
  %dec.i270 = add i32 %i.059.i264, -1
  %cmp23.i271 = icmp eq i32 %dec.i270, 0
  br i1 %cmp23.i271, label %while.cond.loopexit.i254.loopexit, label %for.body.i272, !prof !55

alloc_barray.exit.loopexit:                       ; preds = %while.cond.loopexit.i254
  br label %alloc_barray.exit

alloc_barray.exit:                                ; preds = %alloc_barray.exit.loopexit, %if.end.i251
  %70 = bitcast %struct.jvirt_barray_control* %bptr.1296 to i8**
  store i8* %call.i249, i8** %70, align 8, !tbaa !68
  %71 = load i32, i32* %last_rowsperchunk128, align 8, !tbaa !49
  %rowsperchunk129 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 5
  store i32 %71, i32* %rowsperchunk129, align 8, !tbaa !84
  %cur_start_row130 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 6
  store i32 0, i32* %cur_start_row130, align 4, !tbaa !85
  %first_undef_row131 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 7
  store i32 0, i32* %first_undef_row131, align 8, !tbaa !86
  %dirty132 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 9
  store i32 0, i32* %dirty132, align 8, !tbaa !87
  br label %for.inc134

for.inc134:                                       ; preds = %for.body92, %alloc_barray.exit
  %next135 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.1296, i64 0, i32 11
  %bptr.1 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %next135, align 8, !tbaa !17
  %cmp90 = icmp eq %struct.jvirt_barray_control* %bptr.1, null
  br i1 %cmp90, label %cleanup.loopexit, label %for.body92, !prof !77

cleanup.loopexit:                                 ; preds = %for.inc134
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %for.cond89.preheader, %for.end35
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8** @access_virt_sarray(%struct.jpeg_common_struct* %cinfo, %struct.jvirt_sarray_control* %ptr, i32 %start_row, i32 %num_rows, i32 %writable) #0 !prof !56 {
entry:
  %add = add i32 %num_rows, %start_row
  %rows_in_array = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 1
  %0 = load i32, i32* %rows_in_array, align 8, !tbaa !60
  %cmp = icmp ugt i32 %add, %0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %maxaccess = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 3
  %1 = bitcast i32* %maxaccess to i64*
  %2 = load i64, i64* %1, align 8
  %3 = trunc i64 %2 to i32
  %cmp1 = icmp ult i32 %3, %num_rows
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %mem_buffer = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 0
  %4 = load i8**, i8*** %mem_buffer, align 8, !tbaa !57
  %cmp3 = icmp eq i8** %4, null
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %5 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
  store i32 20, i32* %msg_code, align 8, !tbaa !13
  %6 = bitcast %struct.jpeg_error_mgr* %5 to void (%struct.jpeg_common_struct*)**
  %7 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %6, align 8, !tbaa !16
  tail call void %7(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false2
  %cur_start_row = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 6
  %8 = load i32, i32* %cur_start_row, align 4, !tbaa !80
  %cmp6 = icmp ugt i32 %8, %start_row
  br i1 %cmp6, label %if.then11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end
  %rows_in_mem = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 4
  %9 = load i32, i32* %rows_in_mem, align 4, !tbaa !78
  %add9 = add i32 %9, %8
  %cmp10 = icmp ugt i32 %add, %add9
  br i1 %cmp10, label %if.then11, label %if.end36

if.then11:                                        ; preds = %lor.lhs.false7, %if.end
  %b_s_open = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 10
  %10 = load i32, i32* %b_s_open, align 4, !tbaa !64
  %tobool = icmp eq i32 %10, 0
  br i1 %tobool, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.then11
  %err13 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %11 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err13, align 8, !tbaa !12
  %msg_code14 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %11, i64 0, i32 5
  store i32 68, i32* %msg_code14, align 8, !tbaa !13
  %12 = bitcast %struct.jpeg_error_mgr* %11 to void (%struct.jpeg_common_struct*)**
  %13 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %12, align 8, !tbaa !16
  tail call void %13(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %if.then12
  %dirty = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 9
  %14 = load i32, i32* %dirty, align 8, !tbaa !82
  %tobool19 = icmp eq i32 %14, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end18
  %samplesperrow.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 2
  %15 = load i32, i32* %samplesperrow.i, align 4, !tbaa !61
  %conv.i = zext i32 %15 to i64
  %rows_in_mem.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 4
  %16 = load i32, i32* %rows_in_mem.i, align 4, !tbaa !78
  %cmp96.i = icmp eq i32 %16, 0
  br i1 %cmp96.i, label %do_sarray_io.exit, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.then20
  %conv395.i = zext i32 %16 to i64
  %17 = load i32, i32* %cur_start_row, align 4, !tbaa !80
  %conv1.i = zext i32 %17 to i64
  %mul2.i = mul nuw nsw i64 %conv1.i, %conv.i
  %rowsperchunk.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 5
  %first_undef_row.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 7
  %b_s_info.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 12
  %mem_buffer46.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 0
  %write_backing_store.i = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 12, i32 1
  %18 = bitcast i32* %rowsperchunk.i to i64*
  %.pre101.i = load i64, i64* %18, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %if.end.i, %for.body.lr.ph.i
  %.in.in.i = phi i64 [ %24, %if.end.i ], [ %.pre101.i, %for.body.lr.ph.i ]
  %conv399.i = phi i64 [ %conv3.i, %if.end.i ], [ %conv395.i, %for.body.lr.ph.i ]
  %i.098.i = phi i64 [ %add52.i, %if.end.i ], [ 0, %for.body.lr.ph.i ]
  %file_offset.097.i = phi i64 [ %add49.i, %if.end.i ], [ %mul2.i, %for.body.lr.ph.i ]
  %.in.i = lshr i64 %.in.in.i, 32
  %conv5.i = and i64 %.in.in.i, 4294967295
  %sub.i = sub nsw i64 %conv399.i, %i.098.i
  %cmp8.i = icmp slt i64 %conv5.i, %sub.i
  %conv5.sub.i = select i1 %cmp8.i, i64 %conv5.i, i64 %sub.i
  %add.i = add nsw i64 %i.098.i, %.in.i
  %19 = load i32, i32* %first_undef_row.i, align 8, !tbaa !81
  %conv17.i = zext i32 %19 to i64
  %sub18.i = sub nsw i64 %conv17.i, %add.i
  %cmp19.i = icmp slt i64 %conv5.sub.i, %sub18.i
  %cond27.i = select i1 %cmp19.i, i64 %conv5.sub.i, i64 %sub18.i
  %20 = load i32, i32* %rows_in_array, align 8, !tbaa !60
  %conv28.i = zext i32 %20 to i64
  %sub29.i = sub nsw i64 %conv28.i, %add.i
  %cmp30.i = icmp slt i64 %cond27.i, %sub29.i
  %cond27.sub29.i = select i1 %cmp30.i, i64 %cond27.i, i64 %sub29.i
  %cmp39.i = icmp slt i64 %cond27.sub29.i, 1
  br i1 %cmp39.i, label %do_sarray_io.exit.loopexit, label %if.end.i

if.end.i:                                         ; preds = %for.body.i
  %mul41.i = mul nsw i64 %cond27.sub29.i, %conv.i
  %21 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)** %write_backing_store.i, align 8, !tbaa !88
  %22 = load i8**, i8*** %mem_buffer46.i, align 8, !tbaa !57
  %arrayidx.i = getelementptr inbounds i8*, i8** %22, i64 %i.098.i
  %23 = load i8*, i8** %arrayidx.i, align 8, !tbaa !17
  tail call void %21(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* nonnull %b_s_info.i, i8* %23, i64 %file_offset.097.i, i64 %mul41.i) #5
  %add49.i = add nsw i64 %mul41.i, %file_offset.097.i
  %24 = load i64, i64* %18, align 8
  %conv51.i = and i64 %24, 4294967295
  %add52.i = add nsw i64 %conv51.i, %i.098.i
  %25 = load i32, i32* %rows_in_mem.i, align 4, !tbaa !78
  %conv3.i = zext i32 %25 to i64
  %cmp.i = icmp sgt i64 %conv3.i, %add52.i
  br i1 %cmp.i, label %for.body.i, label %do_sarray_io.exit.loopexit

do_sarray_io.exit.loopexit:                       ; preds = %if.end.i, %for.body.i
  br label %do_sarray_io.exit

do_sarray_io.exit:                                ; preds = %do_sarray_io.exit.loopexit, %if.then20
  store i32 0, i32* %dirty, align 8, !tbaa !82
  br label %if.end22

if.end22:                                         ; preds = %if.end18, %do_sarray_io.exit
  %26 = load i32, i32* %cur_start_row, align 4, !tbaa !80
  %cmp24 = icmp ult i32 %26, %start_row
  br i1 %cmp24, label %if.end22.if.end35_crit_edge, label %if.else

if.end22.if.end35_crit_edge:                      ; preds = %if.end22
  %rows_in_mem.i155.phi.trans.insert = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 4
  %.pre = load i32, i32* %rows_in_mem.i155.phi.trans.insert, align 4, !tbaa !78
  br label %if.end35

if.else:                                          ; preds = %if.end22
  %conv = zext i32 %add to i64
  %rows_in_mem27 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 4
  %27 = load i32, i32* %rows_in_mem27, align 4, !tbaa !78
  %conv28 = zext i32 %27 to i64
  %sub = sub nsw i64 %conv, %conv28
  %cmp29 = icmp slt i64 %sub, 0
  %.sub = select i1 %cmp29, i64 0, i64 %sub
  %conv33 = trunc i64 %.sub to i32
  br label %if.end35

if.end35:                                         ; preds = %if.end22.if.end35_crit_edge, %if.else
  %rows_in_mem.i155.pre-phi = phi i32* [ %rows_in_mem.i155.phi.trans.insert, %if.end22.if.end35_crit_edge ], [ %rows_in_mem27, %if.else ]
  %28 = phi i32 [ %.pre, %if.end22.if.end35_crit_edge ], [ %27, %if.else ]
  %storemerge = phi i32 [ %start_row, %if.end22.if.end35_crit_edge ], [ %conv33, %if.else ]
  store i32 %storemerge, i32* %cur_start_row, align 4, !tbaa !80
  %samplesperrow.i150 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 2
  %29 = load i32, i32* %samplesperrow.i150, align 4, !tbaa !61
  %conv.i151 = zext i32 %29 to i64
  %cmp96.i157 = icmp eq i32 %28, 0
  br i1 %cmp96.i157, label %if.end36, label %for.body.lr.ph.i166

for.body.lr.ph.i166:                              ; preds = %if.end35
  %conv395.i156 = zext i32 %28 to i64
  %conv1.i153 = zext i32 %storemerge to i64
  %mul2.i154 = mul nuw nsw i64 %conv.i151, %conv1.i153
  %rowsperchunk.i158 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 5
  %first_undef_row.i159 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 7
  %b_s_info.i161 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 12
  %read_backing_store.i162 = getelementptr inbounds %struct.backing_store_struct, %struct.backing_store_struct* %b_s_info.i161, i64 0, i32 0
  %mem_buffer46.i163 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 0
  %30 = bitcast i32* %rowsperchunk.i158 to i64*
  %.pre101.i165 = load i64, i64* %30, align 8
  br label %for.body.us.i

for.body.us.i:                                    ; preds = %if.end.us.i, %for.body.lr.ph.i166
  %.in102.in.i = phi i64 [ %36, %if.end.us.i ], [ %.pre101.i165, %for.body.lr.ph.i166 ]
  %conv399.us.i = phi i64 [ %conv3.us.i, %if.end.us.i ], [ %conv395.i156, %for.body.lr.ph.i166 ]
  %i.098.us.i = phi i64 [ %add52.us.i, %if.end.us.i ], [ 0, %for.body.lr.ph.i166 ]
  %file_offset.097.us.i = phi i64 [ %add49.us.i, %if.end.us.i ], [ %mul2.i154, %for.body.lr.ph.i166 ]
  %.in102.i = lshr i64 %.in102.in.i, 32
  %conv5.us.i = and i64 %.in102.in.i, 4294967295
  %sub.us.i = sub nsw i64 %conv399.us.i, %i.098.us.i
  %cmp8.us.i = icmp slt i64 %conv5.us.i, %sub.us.i
  %conv5.sub.us.i = select i1 %cmp8.us.i, i64 %conv5.us.i, i64 %sub.us.i
  %add.us.i = add nsw i64 %i.098.us.i, %.in102.i
  %31 = load i32, i32* %first_undef_row.i159, align 8, !tbaa !81
  %conv17.us.i = zext i32 %31 to i64
  %sub18.us.i = sub nsw i64 %conv17.us.i, %add.us.i
  %cmp19.us.i = icmp slt i64 %conv5.sub.us.i, %sub18.us.i
  %cond27.us.i = select i1 %cmp19.us.i, i64 %conv5.sub.us.i, i64 %sub18.us.i
  %32 = load i32, i32* %rows_in_array, align 8, !tbaa !60
  %conv28.us.i = zext i32 %32 to i64
  %sub29.us.i = sub nsw i64 %conv28.us.i, %add.us.i
  %cmp30.us.i = icmp slt i64 %cond27.us.i, %sub29.us.i
  %cond27.sub29.us.i = select i1 %cmp30.us.i, i64 %cond27.us.i, i64 %sub29.us.i
  %cmp39.us.i = icmp slt i64 %cond27.sub29.us.i, 1
  br i1 %cmp39.us.i, label %if.end36.loopexit, label %if.end.us.i

if.end.us.i:                                      ; preds = %for.body.us.i
  %mul41.us.i = mul nsw i64 %cond27.sub29.us.i, %conv.i151
  %33 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)** %read_backing_store.i162, align 8, !tbaa !89
  %34 = load i8**, i8*** %mem_buffer46.i163, align 8, !tbaa !57
  %arrayidx47.us.i = getelementptr inbounds i8*, i8** %34, i64 %i.098.us.i
  %35 = load i8*, i8** %arrayidx47.us.i, align 8, !tbaa !17
  tail call void %33(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* nonnull %b_s_info.i161, i8* %35, i64 %file_offset.097.us.i, i64 %mul41.us.i) #5
  %add49.us.i = add nsw i64 %mul41.us.i, %file_offset.097.us.i
  %36 = load i64, i64* %30, align 8
  %conv51.us.i = and i64 %36, 4294967295
  %add52.us.i = add nsw i64 %conv51.us.i, %i.098.us.i
  %37 = load i32, i32* %rows_in_mem.i155.pre-phi, align 4, !tbaa !78
  %conv3.us.i = zext i32 %37 to i64
  %cmp.us.i = icmp sgt i64 %conv3.us.i, %add52.us.i
  br i1 %cmp.us.i, label %for.body.us.i, label %if.end36.loopexit

if.end36.loopexit:                                ; preds = %for.body.us.i, %if.end.us.i
  br label %if.end36

if.end36:                                         ; preds = %if.end36.loopexit, %if.end35, %lor.lhs.false7
  %first_undef_row = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 7
  %38 = bitcast i32* %first_undef_row to i64*
  %39 = load i64, i64* %38, align 8
  %40 = trunc i64 %39 to i32
  %cmp37 = icmp ult i32 %40, %add
  %41 = lshr i64 %39, 32
  %42 = trunc i64 %41 to i32
  br i1 %cmp37, label %if.then39, label %if.end79

if.then39:                                        ; preds = %if.end36
  %cmp41 = icmp ult i32 %40, %start_row
  %tobool44 = icmp eq i32 %writable, 0
  br i1 %cmp41, label %if.then43, label %if.end54

if.then43:                                        ; preds = %if.then39
  br i1 %tobool44, label %if.end58, label %if.end54.thread

if.end54.thread:                                  ; preds = %if.then43
  %err46 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err46, align 8, !tbaa !12
  %msg_code47 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 5
  store i32 20, i32* %msg_code47, align 8, !tbaa !13
  %44 = bitcast %struct.jpeg_error_mgr* %43 to void (%struct.jpeg_common_struct*)**
  %45 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %44, align 8, !tbaa !16
  tail call void %45(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.then56

if.end54:                                         ; preds = %if.then39
  br i1 %tobool44, label %if.end58, label %if.then56, !prof !90

if.then56:                                        ; preds = %if.end54, %if.end54.thread
  %undef_row.0170 = phi i32 [ %start_row, %if.end54.thread ], [ %40, %if.end54 ]
  store i32 %add, i32* %first_undef_row, align 8, !tbaa !81
  %pre_zero.phi.trans.insert = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 8
  %.pre177 = load i32, i32* %pre_zero.phi.trans.insert, align 4, !tbaa !63
  br label %if.end58

if.end58:                                         ; preds = %if.end54, %if.then43, %if.then56
  %46 = phi i32 [ %.pre177, %if.then56 ], [ %42, %if.end54 ], [ %42, %if.then43 ]
  %tobool55171 = phi i1 [ true, %if.then56 ], [ false, %if.end54 ], [ false, %if.then43 ]
  %undef_row.0169 = phi i32 [ %undef_row.0170, %if.then56 ], [ %40, %if.end54 ], [ %start_row, %if.then43 ]
  %tobool59 = icmp eq i32 %46, 0
  br i1 %tobool59, label %if.else69, label %if.then60

if.then60:                                        ; preds = %if.end58
  %samplesperrow = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 2
  %47 = load i32, i32* %samplesperrow, align 4, !tbaa !61
  %conv61 = zext i32 %47 to i64
  %48 = load i32, i32* %cur_start_row, align 4, !tbaa !80
  %sub63 = sub i32 %undef_row.0169, %48
  %sub65 = sub i32 %add, %48
  %cmp66175 = icmp ult i32 %sub63, %sub65
  br i1 %cmp66175, label %while.body.lr.ph, label %if.end79

while.body.lr.ph:                                 ; preds = %if.then60
  %mem_buffer68 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 0
  %49 = zext i32 %sub63 to i64
  br label %while.body

while.body:                                       ; preds = %while.body, %while.body.lr.ph
  %indvars.iv = phi i64 [ %49, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ]
  %50 = load i8**, i8*** %mem_buffer68, align 8, !tbaa !57
  %arrayidx = getelementptr inbounds i8*, i8** %50, i64 %indvars.iv
  %51 = load i8*, i8** %arrayidx, align 8, !tbaa !17
  tail call void @jzero_far(i8* %51, i64 %conv61) #5
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %sub65
  br i1 %exitcond, label %if.end79.loopexit, label %while.body

if.else69:                                        ; preds = %if.end58
  br i1 %tobool55171, label %if.end79, label %if.then71

if.then71:                                        ; preds = %if.else69
  %err72 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %52 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err72, align 8, !tbaa !12
  %msg_code73 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %52, i64 0, i32 5
  store i32 20, i32* %msg_code73, align 8, !tbaa !13
  %53 = bitcast %struct.jpeg_error_mgr* %52 to void (%struct.jpeg_common_struct*)**
  %54 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %53, align 8, !tbaa !16
  tail call void %54(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end79

if.end79.loopexit:                                ; preds = %while.body
  br label %if.end79

if.end79:                                         ; preds = %if.end79.loopexit, %if.then60, %if.then71, %if.else69, %if.end36
  %tobool80 = icmp eq i32 %writable, 0
  br i1 %tobool80, label %if.end83, label %if.then81

if.then81:                                        ; preds = %if.end79
  %dirty82 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 9
  store i32 1, i32* %dirty82, align 8, !tbaa !82
  br label %if.end83

if.end83:                                         ; preds = %if.end79, %if.then81
  %mem_buffer84 = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %ptr, i64 0, i32 0
  %55 = load i8**, i8*** %mem_buffer84, align 8, !tbaa !57
  %56 = load i32, i32* %cur_start_row, align 4, !tbaa !80
  %sub86 = sub i32 %start_row, %56
  %idx.ext = zext i32 %sub86 to i64
  %add.ptr = getelementptr inbounds i8*, i8** %55, i64 %idx.ext
  ret i8** %add.ptr
}

; Function Attrs: nounwind uwtable
define internal [64 x i16]** @access_virt_barray(%struct.jpeg_common_struct* %cinfo, %struct.jvirt_barray_control* %ptr, i32 %start_row, i32 %num_rows, i32 %writable) #0 !prof !91 {
entry:
  %add = add i32 %num_rows, %start_row
  %rows_in_array = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 1
  %0 = load i32, i32* %rows_in_array, align 8, !tbaa !70
  %cmp = icmp ugt i32 %add, %0
  br i1 %cmp, label %if.then, label %lor.lhs.false, !prof !92

lor.lhs.false:                                    ; preds = %entry
  %maxaccess = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 3
  %1 = bitcast i32* %maxaccess to i64*
  %2 = load i64, i64* %1, align 8
  %3 = trunc i64 %2 to i32
  %cmp1 = icmp ult i32 %3, %num_rows
  br i1 %cmp1, label %if.then, label %lor.lhs.false2, !prof !92

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %mem_buffer = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 0
  %4 = load [64 x i16]**, [64 x i16]*** %mem_buffer, align 8, !tbaa !68
  %cmp3 = icmp eq [64 x i16]** %4, null
  br i1 %cmp3, label %if.then, label %if.end, !prof !92

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %5 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
  store i32 20, i32* %msg_code, align 8, !tbaa !13
  %6 = bitcast %struct.jpeg_error_mgr* %5 to void (%struct.jpeg_common_struct*)**
  %7 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %6, align 8, !tbaa !16
  tail call void %7(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false2
  %cur_start_row = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 6
  %8 = load i32, i32* %cur_start_row, align 4, !tbaa !85
  %cmp6 = icmp ugt i32 %8, %start_row
  br i1 %cmp6, label %if.then11, label %lor.lhs.false7, !prof !92

lor.lhs.false7:                                   ; preds = %if.end
  %rows_in_mem = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 4
  %9 = load i32, i32* %rows_in_mem, align 4, !tbaa !83
  %add9 = add i32 %9, %8
  %cmp10 = icmp ugt i32 %add, %add9
  br i1 %cmp10, label %if.then11, label %if.end36, !prof !92

if.then11:                                        ; preds = %lor.lhs.false7, %if.end
  %b_s_open = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 10
  %10 = load i32, i32* %b_s_open, align 4, !tbaa !74
  %tobool = icmp eq i32 %10, 0
  br i1 %tobool, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.then11
  %err13 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %11 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err13, align 8, !tbaa !12
  %msg_code14 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %11, i64 0, i32 5
  store i32 68, i32* %msg_code14, align 8, !tbaa !13
  %12 = bitcast %struct.jpeg_error_mgr* %11 to void (%struct.jpeg_common_struct*)**
  %13 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %12, align 8, !tbaa !16
  tail call void %13(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %if.then12
  %dirty = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 9
  %14 = load i32, i32* %dirty, align 8, !tbaa !87
  %tobool19 = icmp eq i32 %14, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end18
  %blocksperrow.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 2
  %15 = load i32, i32* %blocksperrow.i, align 4, !tbaa !71
  %conv.i = zext i32 %15 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 7
  %rows_in_mem.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 4
  %16 = load i32, i32* %rows_in_mem.i, align 4, !tbaa !83
  %cmp96.i = icmp eq i32 %16, 0
  br i1 %cmp96.i, label %do_barray_io.exit, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.then20
  %conv395.i = zext i32 %16 to i64
  %17 = load i32, i32* %cur_start_row, align 4, !tbaa !85
  %conv1.i = zext i32 %17 to i64
  %mul2.i = mul nsw i64 %conv1.i, %mul.i
  %rowsperchunk.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 5
  %first_undef_row.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 7
  %b_s_info.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 12
  %mem_buffer46.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 0
  %write_backing_store.i = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 12, i32 1
  %18 = bitcast i32* %rowsperchunk.i to i64*
  %.pre101.i = load i64, i64* %18, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %if.end.i, %for.body.lr.ph.i
  %.in.in.i = phi i64 [ %25, %if.end.i ], [ %.pre101.i, %for.body.lr.ph.i ]
  %conv399.i = phi i64 [ %conv3.i, %if.end.i ], [ %conv395.i, %for.body.lr.ph.i ]
  %i.098.i = phi i64 [ %add52.i, %if.end.i ], [ 0, %for.body.lr.ph.i ]
  %file_offset.097.i = phi i64 [ %add49.i, %if.end.i ], [ %mul2.i, %for.body.lr.ph.i ]
  %.in.i = lshr i64 %.in.in.i, 32
  %conv5.i = and i64 %.in.in.i, 4294967295
  %sub.i = sub nsw i64 %conv399.i, %i.098.i
  %cmp8.i = icmp slt i64 %conv5.i, %sub.i
  %conv5.sub.i = select i1 %cmp8.i, i64 %conv5.i, i64 %sub.i
  %add.i = add nsw i64 %i.098.i, %.in.i
  %19 = load i32, i32* %first_undef_row.i, align 8, !tbaa !86
  %conv17.i = zext i32 %19 to i64
  %sub18.i = sub nsw i64 %conv17.i, %add.i
  %cmp19.i = icmp slt i64 %conv5.sub.i, %sub18.i
  %cond27.i = select i1 %cmp19.i, i64 %conv5.sub.i, i64 %sub18.i
  %20 = load i32, i32* %rows_in_array, align 8, !tbaa !70
  %conv28.i = zext i32 %20 to i64
  %sub29.i = sub nsw i64 %conv28.i, %add.i
  %cmp30.i = icmp slt i64 %cond27.i, %sub29.i
  %cond27.sub29.i = select i1 %cmp30.i, i64 %cond27.i, i64 %sub29.i
  %cmp39.i = icmp slt i64 %cond27.sub29.i, 1
  br i1 %cmp39.i, label %do_barray_io.exit.loopexit, label %if.end.i

if.end.i:                                         ; preds = %for.body.i
  %mul41.i = mul nsw i64 %cond27.sub29.i, %mul.i
  %21 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)** %write_backing_store.i, align 8, !tbaa !93
  %22 = load [64 x i16]**, [64 x i16]*** %mem_buffer46.i, align 8, !tbaa !68
  %arrayidx.i = getelementptr inbounds [64 x i16]*, [64 x i16]** %22, i64 %i.098.i
  %23 = bitcast [64 x i16]** %arrayidx.i to i8**
  %24 = load i8*, i8** %23, align 8, !tbaa !17
  tail call void %21(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* nonnull %b_s_info.i, i8* %24, i64 %file_offset.097.i, i64 %mul41.i) #5
  %add49.i = add nsw i64 %mul41.i, %file_offset.097.i
  %25 = load i64, i64* %18, align 8
  %conv51.i = and i64 %25, 4294967295
  %add52.i = add nsw i64 %conv51.i, %i.098.i
  %26 = load i32, i32* %rows_in_mem.i, align 4, !tbaa !83
  %conv3.i = zext i32 %26 to i64
  %cmp.i = icmp sgt i64 %conv3.i, %add52.i
  br i1 %cmp.i, label %for.body.i, label %do_barray_io.exit.loopexit

do_barray_io.exit.loopexit:                       ; preds = %if.end.i, %for.body.i
  br label %do_barray_io.exit

do_barray_io.exit:                                ; preds = %do_barray_io.exit.loopexit, %if.then20
  store i32 0, i32* %dirty, align 8, !tbaa !87
  br label %if.end22

if.end22:                                         ; preds = %if.end18, %do_barray_io.exit
  %27 = load i32, i32* %cur_start_row, align 4, !tbaa !85
  %cmp24 = icmp ult i32 %27, %start_row
  br i1 %cmp24, label %if.end22.if.end35_crit_edge, label %if.else

if.end22.if.end35_crit_edge:                      ; preds = %if.end22
  %rows_in_mem.i156.phi.trans.insert = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 4
  %.pre = load i32, i32* %rows_in_mem.i156.phi.trans.insert, align 4, !tbaa !83
  br label %if.end35

if.else:                                          ; preds = %if.end22
  %conv = zext i32 %add to i64
  %rows_in_mem27 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 4
  %28 = load i32, i32* %rows_in_mem27, align 4, !tbaa !83
  %conv28 = zext i32 %28 to i64
  %sub = sub nsw i64 %conv, %conv28
  %cmp29 = icmp slt i64 %sub, 0
  %.sub = select i1 %cmp29, i64 0, i64 %sub
  %conv33 = trunc i64 %.sub to i32
  br label %if.end35

if.end35:                                         ; preds = %if.end22.if.end35_crit_edge, %if.else
  %rows_in_mem.i156.pre-phi = phi i32* [ %rows_in_mem.i156.phi.trans.insert, %if.end22.if.end35_crit_edge ], [ %rows_in_mem27, %if.else ]
  %29 = phi i32 [ %.pre, %if.end22.if.end35_crit_edge ], [ %28, %if.else ]
  %storemerge = phi i32 [ %start_row, %if.end22.if.end35_crit_edge ], [ %conv33, %if.else ]
  store i32 %storemerge, i32* %cur_start_row, align 4, !tbaa !85
  %blocksperrow.i150 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 2
  %30 = load i32, i32* %blocksperrow.i150, align 4, !tbaa !71
  %conv.i151 = zext i32 %30 to i64
  %mul.i152 = shl nuw nsw i64 %conv.i151, 7
  %cmp96.i158 = icmp eq i32 %29, 0
  br i1 %cmp96.i158, label %if.end36, label %for.body.lr.ph.i167

for.body.lr.ph.i167:                              ; preds = %if.end35
  %conv395.i157 = zext i32 %29 to i64
  %conv1.i154 = zext i32 %storemerge to i64
  %mul2.i155 = mul nsw i64 %mul.i152, %conv1.i154
  %rowsperchunk.i159 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 5
  %first_undef_row.i160 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 7
  %b_s_info.i162 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 12
  %read_backing_store.i163 = getelementptr inbounds %struct.backing_store_struct, %struct.backing_store_struct* %b_s_info.i162, i64 0, i32 0
  %mem_buffer46.i164 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 0
  %31 = bitcast i32* %rowsperchunk.i159 to i64*
  %.pre101.i166 = load i64, i64* %31, align 8
  br label %for.body.us.i

for.body.us.i:                                    ; preds = %if.end.us.i, %for.body.lr.ph.i167
  %.in102.in.i = phi i64 [ %38, %if.end.us.i ], [ %.pre101.i166, %for.body.lr.ph.i167 ]
  %conv399.us.i = phi i64 [ %conv3.us.i, %if.end.us.i ], [ %conv395.i157, %for.body.lr.ph.i167 ]
  %i.098.us.i = phi i64 [ %add52.us.i, %if.end.us.i ], [ 0, %for.body.lr.ph.i167 ]
  %file_offset.097.us.i = phi i64 [ %add49.us.i, %if.end.us.i ], [ %mul2.i155, %for.body.lr.ph.i167 ]
  %.in102.i = lshr i64 %.in102.in.i, 32
  %conv5.us.i = and i64 %.in102.in.i, 4294967295
  %sub.us.i = sub nsw i64 %conv399.us.i, %i.098.us.i
  %cmp8.us.i = icmp slt i64 %conv5.us.i, %sub.us.i
  %conv5.sub.us.i = select i1 %cmp8.us.i, i64 %conv5.us.i, i64 %sub.us.i
  %add.us.i = add nsw i64 %i.098.us.i, %.in102.i
  %32 = load i32, i32* %first_undef_row.i160, align 8, !tbaa !86
  %conv17.us.i = zext i32 %32 to i64
  %sub18.us.i = sub nsw i64 %conv17.us.i, %add.us.i
  %cmp19.us.i = icmp slt i64 %conv5.sub.us.i, %sub18.us.i
  %cond27.us.i = select i1 %cmp19.us.i, i64 %conv5.sub.us.i, i64 %sub18.us.i
  %33 = load i32, i32* %rows_in_array, align 8, !tbaa !70
  %conv28.us.i = zext i32 %33 to i64
  %sub29.us.i = sub nsw i64 %conv28.us.i, %add.us.i
  %cmp30.us.i = icmp slt i64 %cond27.us.i, %sub29.us.i
  %cond27.sub29.us.i = select i1 %cmp30.us.i, i64 %cond27.us.i, i64 %sub29.us.i
  %cmp39.us.i = icmp slt i64 %cond27.sub29.us.i, 1
  br i1 %cmp39.us.i, label %if.end36.loopexit, label %if.end.us.i

if.end.us.i:                                      ; preds = %for.body.us.i
  %mul41.us.i = mul nsw i64 %cond27.sub29.us.i, %mul.i152
  %34 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*, i8*, i64, i64)** %read_backing_store.i163, align 8, !tbaa !94
  %35 = load [64 x i16]**, [64 x i16]*** %mem_buffer46.i164, align 8, !tbaa !68
  %arrayidx47.us.i = getelementptr inbounds [64 x i16]*, [64 x i16]** %35, i64 %i.098.us.i
  %36 = bitcast [64 x i16]** %arrayidx47.us.i to i8**
  %37 = load i8*, i8** %36, align 8, !tbaa !17
  tail call void %34(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* nonnull %b_s_info.i162, i8* %37, i64 %file_offset.097.us.i, i64 %mul41.us.i) #5
  %add49.us.i = add nsw i64 %mul41.us.i, %file_offset.097.us.i
  %38 = load i64, i64* %31, align 8
  %conv51.us.i = and i64 %38, 4294967295
  %add52.us.i = add nsw i64 %conv51.us.i, %i.098.us.i
  %39 = load i32, i32* %rows_in_mem.i156.pre-phi, align 4, !tbaa !83
  %conv3.us.i = zext i32 %39 to i64
  %cmp.us.i = icmp sgt i64 %conv3.us.i, %add52.us.i
  br i1 %cmp.us.i, label %for.body.us.i, label %if.end36.loopexit

if.end36.loopexit:                                ; preds = %for.body.us.i, %if.end.us.i
  br label %if.end36

if.end36:                                         ; preds = %if.end36.loopexit, %if.end35, %lor.lhs.false7
  %first_undef_row = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 7
  %40 = bitcast i32* %first_undef_row to i64*
  %41 = load i64, i64* %40, align 8
  %42 = trunc i64 %41 to i32
  %cmp37 = icmp ult i32 %42, %add
  %43 = lshr i64 %41, 32
  %44 = trunc i64 %43 to i32
  br i1 %cmp37, label %if.then39, label %if.end79, !prof !95

if.then39:                                        ; preds = %if.end36
  %cmp41 = icmp ult i32 %42, %start_row
  %tobool44 = icmp eq i32 %writable, 0
  br i1 %cmp41, label %if.then43, label %if.end54, !prof !96

if.then43:                                        ; preds = %if.then39
  br i1 %tobool44, label %if.end58, label %if.end54.thread

if.end54.thread:                                  ; preds = %if.then43
  %err46 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %45 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err46, align 8, !tbaa !12
  %msg_code47 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %45, i64 0, i32 5
  store i32 20, i32* %msg_code47, align 8, !tbaa !13
  %46 = bitcast %struct.jpeg_error_mgr* %45 to void (%struct.jpeg_common_struct*)**
  %47 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %46, align 8, !tbaa !16
  tail call void %47(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.then56

if.end54:                                         ; preds = %if.then39
  br i1 %tobool44, label %if.end58, label %if.then56, !prof !97

if.then56:                                        ; preds = %if.end54, %if.end54.thread
  %undef_row.0171 = phi i32 [ %start_row, %if.end54.thread ], [ %42, %if.end54 ]
  store i32 %add, i32* %first_undef_row, align 8, !tbaa !86
  %pre_zero.phi.trans.insert = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 8
  %.pre178 = load i32, i32* %pre_zero.phi.trans.insert, align 4, !tbaa !73
  br label %if.end58

if.end58:                                         ; preds = %if.end54, %if.then43, %if.then56
  %48 = phi i32 [ %.pre178, %if.then56 ], [ %44, %if.end54 ], [ %44, %if.then43 ]
  %tobool55172 = phi i1 [ true, %if.then56 ], [ false, %if.end54 ], [ false, %if.then43 ]
  %undef_row.0170 = phi i32 [ %undef_row.0171, %if.then56 ], [ %42, %if.end54 ], [ %start_row, %if.then43 ]
  %tobool59 = icmp eq i32 %48, 0
  br i1 %tobool59, label %if.else69, label %if.then60, !prof !98

if.then60:                                        ; preds = %if.end58
  %blocksperrow = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 2
  %49 = load i32, i32* %blocksperrow, align 4, !tbaa !71
  %conv61 = zext i32 %49 to i64
  %mul = shl nuw nsw i64 %conv61, 7
  %50 = load i32, i32* %cur_start_row, align 4, !tbaa !85
  %sub63 = sub i32 %undef_row.0170, %50
  %sub65 = sub i32 %add, %50
  %cmp66176 = icmp ult i32 %sub63, %sub65
  br i1 %cmp66176, label %while.body.lr.ph, label %if.end79

while.body.lr.ph:                                 ; preds = %if.then60
  %mem_buffer68 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 0
  %51 = zext i32 %sub63 to i64
  br label %while.body

while.body:                                       ; preds = %while.body, %while.body.lr.ph
  %indvars.iv = phi i64 [ %51, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ]
  %52 = load [64 x i16]**, [64 x i16]*** %mem_buffer68, align 8, !tbaa !68
  %arrayidx = getelementptr inbounds [64 x i16]*, [64 x i16]** %52, i64 %indvars.iv
  %53 = bitcast [64 x i16]** %arrayidx to i8**
  %54 = load i8*, i8** %53, align 8, !tbaa !17
  tail call void @jzero_far(i8* %54, i64 %mul) #5
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %sub65
  br i1 %exitcond, label %if.end79.loopexit, label %while.body

if.else69:                                        ; preds = %if.end58
  br i1 %tobool55172, label %if.end79, label %if.then71, !prof !98

if.then71:                                        ; preds = %if.else69
  %err72 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %55 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err72, align 8, !tbaa !12
  %msg_code73 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 5
  store i32 20, i32* %msg_code73, align 8, !tbaa !13
  %56 = bitcast %struct.jpeg_error_mgr* %55 to void (%struct.jpeg_common_struct*)**
  %57 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %56, align 8, !tbaa !16
  tail call void %57(%struct.jpeg_common_struct* %cinfo) #5
  br label %if.end79

if.end79.loopexit:                                ; preds = %while.body
  br label %if.end79

if.end79:                                         ; preds = %if.end79.loopexit, %if.then60, %if.then71, %if.else69, %if.end36
  %tobool80 = icmp eq i32 %writable, 0
  br i1 %tobool80, label %if.end83, label %if.then81, !prof !99

if.then81:                                        ; preds = %if.end79
  %dirty82 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 9
  store i32 1, i32* %dirty82, align 8, !tbaa !87
  br label %if.end83

if.end83:                                         ; preds = %if.end79, %if.then81
  %mem_buffer84 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %ptr, i64 0, i32 0
  %58 = load [64 x i16]**, [64 x i16]*** %mem_buffer84, align 8, !tbaa !68
  %59 = load i32, i32* %cur_start_row, align 4, !tbaa !85
  %sub86 = sub i32 %start_row, %59
  %idx.ext = zext i32 %sub86 to i64
  %add.ptr = getelementptr inbounds [64 x i16]*, [64 x i16]** %58, i64 %idx.ext
  ret [64 x i16]** %add.ptr
}

; Function Attrs: nounwind uwtable
define internal void @free_pool(%struct.jpeg_common_struct* %cinfo, i32 %pool_id) #0 !prof !52 {
entry:
  %mem1 = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem1 to %struct.my_memory_mgr**
  %1 = load %struct.my_memory_mgr*, %struct.my_memory_mgr** %0, align 8, !tbaa !3
  %2 = icmp ugt i32 %pool_id, 1
  br i1 %2, label %if.end.thread, label %if.end, !prof !100

if.end.thread:                                    ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 0
  %3 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  store i32 12, i32* %msg_code, align 8, !tbaa !13
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
  store i32 %pool_id, i32* %arrayidx, align 4, !tbaa !15
  %4 = bitcast %struct.jpeg_error_mgr* %3 to void (%struct.jpeg_common_struct*)**
  %5 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %4, align 8, !tbaa !16
  tail call void %5(%struct.jpeg_common_struct* nonnull %cinfo) #5
  br label %if.end29

if.end:                                           ; preds = %entry
  %cmp6 = icmp eq i32 %pool_id, 1
  br i1 %cmp6, label %if.then7, label %if.end29, !prof !101

if.then7:                                         ; preds = %if.end
  %virt_sarray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 3
  %sptr.0119 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %virt_sarray_list, align 8, !tbaa !17
  %cmp8120 = icmp eq %struct.jvirt_sarray_control* %sptr.0119, null
  br i1 %cmp8120, label %for.end, label %for.body.preheader, !prof !102

for.body.preheader:                               ; preds = %if.then7
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %sptr.0121 = phi %struct.jvirt_sarray_control* [ %sptr.0, %for.inc ], [ %sptr.0119, %for.body.preheader ]
  %b_s_open = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0121, i64 0, i32 10
  %6 = load i32, i32* %b_s_open, align 4, !tbaa !64
  %tobool = icmp eq i32 %6, 0
  br i1 %tobool, label %for.inc, label %if.then9

if.then9:                                         ; preds = %for.body
  store i32 0, i32* %b_s_open, align 4, !tbaa !64
  %b_s_info = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0121, i64 0, i32 12
  %close_backing_store = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0121, i64 0, i32 12, i32 2
  %7 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*)** %close_backing_store, align 8, !tbaa !103
  tail call void %7(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* %b_s_info) #5
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then9
  %next = getelementptr inbounds %struct.jvirt_sarray_control, %struct.jvirt_sarray_control* %sptr.0121, i64 0, i32 11
  %sptr.0 = load %struct.jvirt_sarray_control*, %struct.jvirt_sarray_control** %next, align 8, !tbaa !17
  %cmp8 = icmp eq %struct.jvirt_sarray_control* %sptr.0, null
  br i1 %cmp8, label %for.end.loopexit, label %for.body, !prof !102

for.end.loopexit:                                 ; preds = %for.inc
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then7
  store %struct.jvirt_sarray_control* null, %struct.jvirt_sarray_control** %virt_sarray_list, align 8, !tbaa !65
  %virt_barray_list = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 4
  %bptr.0116 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %virt_barray_list, align 8, !tbaa !17
  %cmp15117 = icmp eq %struct.jvirt_barray_control* %bptr.0116, null
  br i1 %cmp15117, label %for.end27, label %for.body16.preheader, !prof !104

for.body16.preheader:                             ; preds = %for.end
  br label %for.body16

for.body16:                                       ; preds = %for.body16.preheader, %for.inc25
  %bptr.0118 = phi %struct.jvirt_barray_control* [ %bptr.0, %for.inc25 ], [ %bptr.0116, %for.body16.preheader ]
  %b_s_open17 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0118, i64 0, i32 10
  %8 = load i32, i32* %b_s_open17, align 4, !tbaa !74
  %tobool18 = icmp eq i32 %8, 0
  br i1 %tobool18, label %for.inc25, label %if.then19, !prof !67

if.then19:                                        ; preds = %for.body16
  store i32 0, i32* %b_s_open17, align 4, !tbaa !74
  %b_s_info21 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0118, i64 0, i32 12
  %close_backing_store22 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0118, i64 0, i32 12, i32 2
  %9 = load void (%struct.jpeg_common_struct*, %struct.backing_store_struct*)*, void (%struct.jpeg_common_struct*, %struct.backing_store_struct*)** %close_backing_store22, align 8, !tbaa !105
  tail call void %9(%struct.jpeg_common_struct* %cinfo, %struct.backing_store_struct* %b_s_info21) #5
  br label %for.inc25

for.inc25:                                        ; preds = %for.body16, %if.then19
  %next26 = getelementptr inbounds %struct.jvirt_barray_control, %struct.jvirt_barray_control* %bptr.0118, i64 0, i32 11
  %bptr.0 = load %struct.jvirt_barray_control*, %struct.jvirt_barray_control** %next26, align 8, !tbaa !17
  %cmp15 = icmp eq %struct.jvirt_barray_control* %bptr.0, null
  br i1 %cmp15, label %for.end27.loopexit, label %for.body16, !prof !104

for.end27.loopexit:                               ; preds = %for.inc25
  br label %for.end27

for.end27:                                        ; preds = %for.end27.loopexit, %for.end
  store %struct.jvirt_barray_control* null, %struct.jvirt_barray_control** %virt_barray_list, align 8, !tbaa !75
  br label %if.end29

if.end29:                                         ; preds = %if.end.thread, %for.end27, %if.end
  %idxprom = sext i32 %pool_id to i64
  %arrayidx30 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 2, i64 %idxprom
  %10 = load %union.large_pool_struct*, %union.large_pool_struct** %arrayidx30, align 8, !tbaa !17
  store %union.large_pool_struct* null, %union.large_pool_struct** %arrayidx30, align 8, !tbaa !17
  %cmp34114 = icmp eq %union.large_pool_struct* %10, null
  br i1 %cmp34114, label %while.end, label %while.body.lr.ph, !prof !106

while.body.lr.ph:                                 ; preds = %if.end29
  %total_space_allocated = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 5
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %lhdr_ptr.0115 = phi %union.large_pool_struct* [ %10, %while.body.lr.ph ], [ %11, %while.body ]
  %next35 = getelementptr inbounds %union.large_pool_struct, %union.large_pool_struct* %lhdr_ptr.0115, i64 0, i32 0, i32 0
  %11 = load %union.large_pool_struct*, %union.large_pool_struct** %next35, align 8, !tbaa !42
  %bytes_used = getelementptr inbounds %union.large_pool_struct, %union.large_pool_struct* %lhdr_ptr.0115, i64 0, i32 0, i32 1
  %12 = load i64, i64* %bytes_used, align 8, !tbaa !43
  %bytes_left = getelementptr inbounds %union.large_pool_struct, %union.large_pool_struct* %lhdr_ptr.0115, i64 0, i32 0, i32 2
  %13 = load i64, i64* %bytes_left, align 8, !tbaa !37
  %add = add i64 %12, 24
  %add38 = add i64 %add, %13
  %14 = bitcast %union.large_pool_struct* %lhdr_ptr.0115 to i8*
  tail call void @jpeg_free_large(%struct.jpeg_common_struct* %cinfo, i8* %14, i64 %add38) #5
  %15 = load i64, i64* %total_space_allocated, align 8, !tbaa !30
  %sub = sub i64 %15, %add38
  store i64 %sub, i64* %total_space_allocated, align 8, !tbaa !30
  %cmp34 = icmp eq %union.large_pool_struct* %11, null
  br i1 %cmp34, label %while.end.loopexit, label %while.body, !prof !106

while.end.loopexit:                               ; preds = %while.body
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %if.end29
  %arrayidx40 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 1, i64 %idxprom
  %16 = load %union.small_pool_struct*, %union.small_pool_struct** %arrayidx40, align 8, !tbaa !17
  store %union.small_pool_struct* null, %union.small_pool_struct** %arrayidx40, align 8, !tbaa !17
  %cmp45112 = icmp eq %union.small_pool_struct* %16, null
  br i1 %cmp45112, label %while.end57, label %while.body46.lr.ph, !prof !107

while.body46.lr.ph:                               ; preds = %while.end
  %total_space_allocated55 = getelementptr inbounds %struct.my_memory_mgr, %struct.my_memory_mgr* %1, i64 0, i32 5
  br label %while.body46

while.body46:                                     ; preds = %while.body46.lr.ph, %while.body46
  %shdr_ptr.0113 = phi %union.small_pool_struct* [ %16, %while.body46.lr.ph ], [ %17, %while.body46 ]
  %next48 = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %shdr_ptr.0113, i64 0, i32 0, i32 0
  %17 = load %union.small_pool_struct*, %union.small_pool_struct** %next48, align 8, !tbaa !42
  %bytes_used50 = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %shdr_ptr.0113, i64 0, i32 0, i32 1
  %18 = load i64, i64* %bytes_used50, align 8, !tbaa !43
  %bytes_left52 = getelementptr inbounds %union.small_pool_struct, %union.small_pool_struct* %shdr_ptr.0113, i64 0, i32 0, i32 2
  %19 = load i64, i64* %bytes_left52, align 8, !tbaa !37
  %add53 = add i64 %18, 24
  %add54 = add i64 %add53, %19
  %20 = bitcast %union.small_pool_struct* %shdr_ptr.0113 to i8*
  tail call void @jpeg_free_small(%struct.jpeg_common_struct* %cinfo, i8* %20, i64 %add54) #5
  %21 = load i64, i64* %total_space_allocated55, align 8, !tbaa !30
  %sub56 = sub i64 %21, %add54
  store i64 %sub56, i64* %total_space_allocated55, align 8, !tbaa !30
  %cmp45 = icmp eq %union.small_pool_struct* %17, null
  br i1 %cmp45, label %while.end57.loopexit, label %while.body46, !prof !107

while.end57.loopexit:                             ; preds = %while.body46
  br label %while.end57

while.end57:                                      ; preds = %while.end57.loopexit, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @self_destruct(%struct.jpeg_common_struct* %cinfo) #0 !prof !2 {
entry:
  tail call void @free_pool(%struct.jpeg_common_struct* %cinfo, i32 1)
  tail call void @free_pool(%struct.jpeg_common_struct* %cinfo, i32 0)
  %mem = getelementptr inbounds %struct.jpeg_common_struct, %struct.jpeg_common_struct* %cinfo, i64 0, i32 1
  %0 = bitcast %struct.jpeg_memory_mgr** %mem to i8**
  %1 = load i8*, i8** %0, align 8, !tbaa !3
  tail call void @jpeg_free_small(%struct.jpeg_common_struct* %cinfo, i8* %1, i64 160) #5
  store %struct.jpeg_memory_mgr* null, %struct.jpeg_memory_mgr** %mem, align 8, !tbaa !3
  tail call void @jpeg_mem_term(%struct.jpeg_common_struct* %cinfo) #5
  ret void
}

; Function Attrs: nounwind readonly
declare i8* @getenv(i8* nocapture) #3

; Function Attrs: nounwind
declare i32 @__isoc99_sscanf(i8* nocapture readonly, i8* nocapture readonly, ...) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

declare i8* @jpeg_get_large(%struct.jpeg_common_struct*, i64) #2

declare i64 @jpeg_mem_available(%struct.jpeg_common_struct*, i64, i64, i64) #2

declare void @jpeg_open_backing_store(%struct.jpeg_common_struct*, %struct.backing_store_struct*, i64) #2

declare void @jzero_far(i8*, i64) #2

declare void @jpeg_free_large(%struct.jpeg_common_struct*, i8*, i64) #2

declare void @jpeg_free_small(%struct.jpeg_common_struct*, i8*, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"MaxFunctionCount", i32 150581}
!1 = !{!"clang version 3.8.0 (trunk 257473)"}
!2 = !{!"function_entry_count", i64 1}
!3 = !{!4, !5, i64 8}
!4 = !{!"jpeg_common_struct", !5, i64 0, !5, i64 8, !5, i64 16, !8, i64 24, !8, i64 28}
!5 = !{!"any pointer", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!"int", !6, i64 0}
!9 = !{!10, !10, i64 0}
!10 = !{!"long", !6, i64 0}
!11 = !{!"branch_weights", i32 1, i32 2}
!12 = !{!4, !5, i64 0}
!13 = !{!14, !8, i64 40}
!14 = !{!"jpeg_error_mgr", !5, i64 0, !5, i64 8, !5, i64 16, !5, i64 24, !5, i64 32, !8, i64 40, !6, i64 44, !8, i64 124, !10, i64 128, !5, i64 136, !8, i64 144, !5, i64 152, !8, i64 160, !8, i64 164}
!15 = !{!8, !8, i64 0}
!16 = !{!14, !5, i64 0}
!17 = !{!5, !5, i64 0}
!18 = !{!19, !5, i64 16}
!19 = !{!"", !20, i64 0, !6, i64 96, !6, i64 112, !5, i64 128, !5, i64 136, !10, i64 144, !8, i64 152}
!20 = !{!"jpeg_memory_mgr", !5, i64 0, !5, i64 8, !5, i64 16, !5, i64 24, !5, i64 32, !5, i64 40, !5, i64 48, !5, i64 56, !5, i64 64, !5, i64 72, !5, i64 80, !10, i64 88}
!21 = !{!19, !5, i64 24}
!22 = !{!19, !5, i64 32}
!23 = !{!19, !5, i64 40}
!24 = !{!19, !5, i64 48}
!25 = !{!19, !5, i64 56}
!26 = !{!19, !5, i64 64}
!27 = !{!19, !5, i64 72}
!28 = !{!19, !5, i64 80}
!29 = !{!19, !10, i64 88}
!30 = !{!19, !10, i64 144}
!31 = !{!"branch_weights", i32 2, i32 1}
!32 = !{!6, !6, i64 0}
!33 = !{!"function_entry_count", i64 41}
!34 = !{!"branch_weights", i32 1, i32 42}
!35 = !{!"branch_weights", i32 85, i32 1764}
!36 = !{!"branch_weights", i32 5, i32 41}
!37 = !{!38, !10, i64 16}
!38 = !{!"", !5, i64 0, !10, i64 8, !10, i64 16}
!39 = !{!"branch_weights", i32 4, i32 38}
!40 = !{!"branch_weights", i32 1, i32 5}
!41 = !{!"branch_weights", i32 3, i32 3}
!42 = !{!38, !5, i64 0}
!43 = !{!38, !10, i64 8}
!44 = !{!"function_entry_count", i64 9}
!45 = !{!"branch_weights", i32 1, i32 10}
!46 = !{!"branch_weights", i32 21, i32 100}
!47 = !{!"function_entry_count", i64 6}
!48 = !{!"branch_weights", i32 1, i32 7}
!49 = !{!19, !8, i64 152}
!50 = !{!"branch_weights", i32 7, i32 7}
!51 = !{!"branch_weights", i32 7, i32 39}
!52 = !{!"function_entry_count", i64 3}
!53 = !{!"branch_weights", i32 1, i32 4}
!54 = !{!"branch_weights", i32 4, i32 4}
!55 = !{!"branch_weights", i32 4, i32 129}
!56 = !{!"function_entry_count", i64 0}
!57 = !{!58, !5, i64 0}
!58 = !{!"jvirt_sarray_control", !5, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !8, i64 24, !8, i64 28, !8, i64 32, !8, i64 36, !8, i64 40, !8, i64 44, !5, i64 48, !59, i64 56}
!59 = !{!"backing_store_struct", !5, i64 0, !5, i64 8, !5, i64 16, !5, i64 24, !6, i64 32}
!60 = !{!58, !8, i64 8}
!61 = !{!58, !8, i64 12}
!62 = !{!58, !8, i64 16}
!63 = !{!58, !8, i64 36}
!64 = !{!58, !8, i64 44}
!65 = !{!19, !5, i64 128}
!66 = !{!58, !5, i64 48}
!67 = !{!"branch_weights", i32 4, i32 1}
!68 = !{!69, !5, i64 0}
!69 = !{!"jvirt_barray_control", !5, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !8, i64 24, !8, i64 28, !8, i64 32, !8, i64 36, !8, i64 40, !8, i64 44, !5, i64 48, !59, i64 56}
!70 = !{!69, !8, i64 8}
!71 = !{!69, !8, i64 12}
!72 = !{!69, !8, i64 16}
!73 = !{!69, !8, i64 36}
!74 = !{!69, !8, i64 44}
!75 = !{!19, !5, i64 136}
!76 = !{!69, !5, i64 48}
!77 = !{!"branch_weights", i32 2, i32 4}
!78 = !{!58, !8, i64 20}
!79 = !{!58, !8, i64 24}
!80 = !{!58, !8, i64 28}
!81 = !{!58, !8, i64 32}
!82 = !{!58, !8, i64 40}
!83 = !{!69, !8, i64 20}
!84 = !{!69, !8, i64 24}
!85 = !{!69, !8, i64 28}
!86 = !{!69, !8, i64 32}
!87 = !{!69, !8, i64 40}
!88 = !{!58, !5, i64 64}
!89 = !{!58, !5, i64 56}
!90 = !{!"branch_weights", i32 843654290, i32 1303829358}
!91 = !{!"function_entry_count", i64 896}
!92 = !{!"branch_weights", i32 1, i32 897}
!93 = !{!69, !5, i64 64}
!94 = !{!69, !5, i64 56}
!95 = !{!"branch_weights", i32 97, i32 801}
!96 = !{!"branch_weights", i32 1, i32 97}
!97 = !{!"branch_weights", i32 13843569, i32 2133640079}
!98 = !{!"branch_weights", i32 97, i32 1}
!99 = !{!"branch_weights", i32 801, i32 97}
!100 = !{!"branch_weights", i32 9, i32 16}
!101 = !{!"branch_weights", i32 2037356282, i32 110127366}
!102 = !{!"branch_weights", i32 3, i32 1}
!103 = !{!58, !5, i64 72}
!104 = !{!"branch_weights", i32 3, i32 4}
!105 = !{!69, !5, i64 72}
!106 = !{!"branch_weights", i32 4, i32 10}
!107 = !{!"branch_weights", i32 4, i32 5}
